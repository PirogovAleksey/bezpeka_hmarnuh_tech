<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Конспект лекції 5: Безпека безсерверних обчислень (Serverless Security).">
  <meta name="author" content="Кафедра ТЕІБ, Ужгородський національний університет">
  <meta name="theme-color" content="#0ea5e9">
  <title>Конспект лекції 5 — Безпека хмарних технологій</title>
  <link rel="icon" type="image/svg+xml" href="../img/favicon.svg">
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
  <script>
    if (localStorage.getItem('theme') === 'dark') {
      document.documentElement.classList.add('dark');
    }
  </script>
</head>
<body>

  <aside>
    <div class="logo">
      <div class="logo-icon">
        <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/>
          <path d="M12 13v-1a2 2 0 0 1 2-2h0a2 2 0 0 1 2 2v1"/>
          <rect x="10" y="13" width="8" height="5" rx="1"/>
        </svg>
      </div>
      <div class="logo-text">
        Безпека<br>хмарних технологій
        <span>онлайн-курс</span>
      </div>
    </div>

    <nav>
      <a href="../index.html" class="active">
        <span class="nav-icon"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg></span>
        Лекції
      </a>
      <a href="../practicals.html">
        <span class="nav-icon"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg></span>
        Семінари
      </a>
      <a href="../tests.html">
        <span class="nav-icon"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></span>
        Тести
      </a>
      <a href="../materials.html">
        <span class="nav-icon"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/></svg></span>
        Матеріали
      </a>
    </nav>

    <div class="sidebar-footer">
      <button class="theme-toggle" onclick="toggleTheme()" aria-label="Перемкнути тему">
        <svg id="theme-icon" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" aria-hidden="true"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
        <span id="theme-label">Темна тема</span>
      </button>
    </div>
  </aside>

  <main>
    <div class="lecture-nav-top">
      <a href="../lecture.html?id=5" class="back-link">← Назад до лекції</a>
      <span class="lecture-badge">Конспект</span>
    </div>

    <article class="lecture-content">
      <h1>Лекція 5. Безпека безсерверних обчислень (Serverless Security)</h1>
      <div class="lecture-info">
        <span><svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2" style="vertical-align: -2px; margin-right: 4px;"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>2 год</span>
      </div>

      <section>
        <h2>Вступ</h2>
        <p>Безсерверні обчислення (Serverless Computing) — це модель хмарних обчислень, яка революціонізує спосіб розробки та розгортання додатків. Незважаючи на назву, сервери все ще існують — просто розробники більше не турбуються про їхнє управління.</p>

        <p>У цій лекції ми розглянемо, як працює serverless, які унікальні безпекові виклики він створює, і як сучасні технології ізоляції (Firecracker, gVisor) забезпечують безпеку в multi-tenant середовищах.</p>

        <h3>Чому Serverless популярний?</h3>
        <ul>
          <li><strong>Немає управління інфраструктурою:</strong> провайдер керує серверами</li>
          <li><strong>Автоматичне масштабування:</strong> від 0 до мільйонів запитів</li>
          <li><strong>Pay-per-use:</strong> оплата тільки за фактичне виконання</li>
          <li><strong>Швидкий time-to-market:</strong> фокус на бізнес-логіці</li>
        </ul>

        <h3>Цілі лекції</h3>
        <p>Після цієї лекції ви зможете:</p>
        <ul>
          <li>Пояснити архітектуру serverless та різницю між FaaS і BaaS</li>
          <li>Ідентифікувати специфічні загрози та вразливості serverless-додатків</li>
          <li>Розуміти технології ізоляції: Firecracker, gVisor, Kata Containers</li>
          <li>Застосовувати best practices безпеки при розробці serverless-додатків</li>
        </ul>
      </section>

      <section>
        <h2>5.1 Архітектура Serverless</h2>

        <h3>Що таке Serverless?</h3>
        <p><strong>Serverless Computing</strong> — це модель виконання, де хмарний провайдер динамічно управляє виділенням та масштабуванням серверних ресурсів. Розробник пише код, а все інше — відповідальність провайдера.</p>

        <p>Ключові характеристики serverless:</p>
        <ul>
          <li><strong>Event-driven:</strong> код виконується у відповідь на події</li>
          <li><strong>Stateless:</strong> функції не зберігають стан між викликами</li>
          <li><strong>Ephemeral:</strong> контейнери створюються та знищуються динамічно</li>
          <li><strong>Auto-scaling:</strong> масштабування від 0 до необмеженої кількості</li>
          <li><strong>Pay-per-execution:</strong> оплата за кількість викликів та час виконання</li>
        </ul>

        <h3>FaaS — Function as a Service</h3>
        <p><strong>FaaS</strong> — основна модель serverless, де одиницею розгортання є функція — невеликий фрагмент коду, який виконує одну задачу.</p>

        <h4>Провайдери FaaS</h4>
        <table>
          <tr>
            <th>Провайдер</th>
            <th>Сервіс</th>
            <th>Особливості</th>
          </tr>
          <tr>
            <td>AWS</td>
            <td>Lambda</td>
            <td>Найпопулярніший, широка інтеграція з AWS сервісами</td>
          </tr>
          <tr>
            <td>Azure</td>
            <td>Functions</td>
            <td>Глибока інтеграція з .NET, Durable Functions</td>
          </tr>
          <tr>
            <td>Google Cloud</td>
            <td>Cloud Functions</td>
            <td>Cloud Run для контейнерів</td>
          </tr>
          <tr>
            <td>Cloudflare</td>
            <td>Workers</td>
            <td>Edge computing, V8 isolates</td>
          </tr>
        </table>

        <h4>Життєвий цикл Lambda функції</h4>
        <ol>
          <li><strong>Cold Start:</strong> Створення нового execution environment (контейнера)</li>
          <li><strong>Init:</strong> Завантаження коду, ініціалізація runtime</li>
          <li><strong>Invoke:</strong> Виконання handler функції</li>
          <li><strong>Warm:</strong> Контейнер залишається "теплим" для повторних викликів</li>
          <li><strong>Shutdown:</strong> Знищення контейнера після періоду неактивності</li>
        </ol>

        <p><strong>Cold Start</strong> — це затримка при першому виклику функції або після періоду неактивності. Час cold start залежить від:</p>
        <ul>
          <li>Мови програмування (Python, Node.js швидші за Java, .NET)</li>
          <li>Розміру пакету deployment</li>
          <li>VPC конфігурації</li>
          <li>Provisioned concurrency</li>
        </ul>

        <h3>BaaS — Backend as a Service</h3>
        <p><strong>BaaS</strong> — модель, де провайдер надає готові backend-компоненти як сервіси:</p>
        <ul>
          <li><strong>Authentication:</strong> AWS Cognito, Auth0, Firebase Auth</li>
          <li><strong>Database:</strong> Firebase Firestore, AWS DynamoDB</li>
          <li><strong>Storage:</strong> AWS S3, Firebase Storage</li>
          <li><strong>Messaging:</strong> AWS SNS/SQS, Firebase Cloud Messaging</li>
          <li><strong>API Gateway:</strong> AWS API Gateway, Azure API Management</li>
        </ul>

        <p>BaaS дозволяє будувати додатки майже без власного backend-коду, використовуючи готові сервіси.</p>

        <h3>Event-Driven Architecture</h3>
        <p>Serverless-додатки типово базуються на event-driven архітектурі:</p>

        <h4>Типи тригерів</h4>
        <ul>
          <li><strong>HTTP/API:</strong> REST API через API Gateway</li>
          <li><strong>Schedule:</strong> Cron-подібні scheduled events</li>
          <li><strong>Storage:</strong> Завантаження файлу в S3</li>
          <li><strong>Database:</strong> Зміни в DynamoDB Streams</li>
          <li><strong>Queue:</strong> Повідомлення в SQS, Kafka</li>
          <li><strong>IoT:</strong> Eventi від IoT пристроїв</li>
        </ul>

        <h3>Serverless vs Containers vs VMs</h3>
        <table>
          <tr>
            <th>Аспект</th>
            <th>VMs</th>
            <th>Containers</th>
            <th>Serverless</th>
          </tr>
          <tr>
            <td>Абстракція</td>
            <td>Hardware</td>
            <td>OS</td>
            <td>Runtime</td>
          </tr>
          <tr>
            <td>Масштабування</td>
            <td>Хвилини</td>
            <td>Секунди</td>
            <td>Мілісекунди</td>
          </tr>
          <tr>
            <td>Управління</td>
            <td>Повне</td>
            <td>Часткове</td>
            <td>Мінімальне</td>
          </tr>
          <tr>
            <td>Стан</td>
            <td>Stateful</td>
            <td>Stateful/Stateless</td>
            <td>Stateless</td>
          </tr>
          <tr>
            <td>Оплата</td>
            <td>За час роботи</td>
            <td>За час роботи</td>
            <td>За виконання</td>
          </tr>
          <tr>
            <td>Cold Start</td>
            <td>Хвилини</td>
            <td>Секунди</td>
            <td>Мілісекунди-секунди</td>
          </tr>
        </table>

        <h3>Shared Responsibility в Serverless</h3>
        <p>У serverless-моделі розподіл відповідальності суттєво зміщується до провайдера:</p>

        <h4>Провайдер відповідає за:</h4>
        <ul>
          <li>Фізичну безпеку</li>
          <li>Гіпервізор та ізоляцію</li>
          <li>Операційну систему</li>
          <li>Runtime середовище</li>
          <li>Патчі та оновлення</li>
        </ul>

        <h4>Клієнт відповідає за:</h4>
        <ul>
          <li>Код функції</li>
          <li>Залежності та бібліотеки</li>
          <li>IAM та дозволи</li>
          <li>Дані та їх шифрування</li>
          <li>Конфігурацію (env variables, timeouts)</li>
        </ul>
      </section>

      <section>
        <h2>5.2 Загрози та вразливості Serverless</h2>

        <h3>OWASP Serverless Top 10</h3>
        <p>OWASP випустив специфічний список загроз для serverless-додатків:</p>

        <h4>1. Injection (Ін'єкції)</h4>
        <p>Класичні ін'єкції залишаються актуальними:</p>
        <ul>
          <li><strong>SQL Injection:</strong> при взаємодії з базами даних</li>
          <li><strong>NoSQL Injection:</strong> DynamoDB, MongoDB</li>
          <li><strong>OS Command Injection:</strong> при виклику системних команд</li>
          <li><strong>Event Injection:</strong> специфічна для serverless — маніпуляція event data</li>
        </ul>

        <pre>
// Вразливий код — event injection
exports.handler = async (event) => {
  const filename = event.queryStringParameters.file;
  // Атакуючий може передати: ../../../etc/passwd
  const data = fs.readFileSync('/tmp/' + filename);
  return { body: data.toString() };
};
        </pre>

        <h4>2. Broken Authentication</h4>
        <p>Проблеми з автентифікацією в serverless:</p>
        <ul>
          <li>Відсутність автентифікації для internal functions</li>
          <li>Слабка валідація JWT токенів</li>
          <li>Hardcoded credentials в коді</li>
          <li>Неправильна конфігурація API Gateway authorizers</li>
        </ul>

        <h4>3. Sensitive Data Exposure</h4>
        <ul>
          <li>Секрети в environment variables (видимі в console)</li>
          <li>Логування чутливих даних</li>
          <li>Незашифровані дані в transit</li>
          <li>Витік через error messages</li>
        </ul>

        <h4>4. Denial of Service (DoS)</h4>
        <p>Serverless має специфічні DoS-вектори:</p>
        <ul>
          <li><strong>Financial DoS:</strong> атакуючий викликає функцію мільйони разів — величезний рахунок</li>
          <li><strong>Concurrency Exhaustion:</strong> вичерпання ліміту одночасних виконань</li>
          <li><strong>Downstream DoS:</strong> функція атакує backend-сервіси</li>
          <li><strong>ReDoS:</strong> Regex Denial of Service через складні патерни</li>
        </ul>

        <h4>5. Broken Access Control</h4>
        <ul>
          <li>Занадто широкі IAM permissions</li>
          <li>Відсутність перевірки прав на рівні функції</li>
          <li>Insecure Direct Object Reference (IDOR)</li>
        </ul>

        <h4>6. Security Misconfiguration</h4>
        <ul>
          <li>Публічні S3 buckets</li>
          <li>Відкриті API endpoints</li>
          <li>Debug mode в production</li>
          <li>Default configurations</li>
        </ul>

        <h4>7. Insufficient Logging & Monitoring</h4>
        <p>Розподілена природа serverless ускладнює моніторинг:</p>
        <ul>
          <li>Логи розкидані по різних сервісах</li>
          <li>Складність трасування запитів</li>
          <li>Ephemeral nature — контейнери зникають</li>
        </ul>

        <h4>8. Insecure Third-Party Dependencies</h4>
        <ul>
          <li>Вразливі npm/pip пакети</li>
          <li>Supply chain attacks</li>
          <li>Outdated dependencies</li>
        </ul>

        <h4>9. Improper Exception Handling</h4>
        <ul>
          <li>Stack traces в відповідях</li>
          <li>Витік internal paths</li>
          <li>Uncaught exceptions</li>
        </ul>

        <h4>10. Inadequate Function Permissions</h4>
        <ul>
          <li>Overly permissive execution roles</li>
          <li>Cross-function privilege escalation</li>
          <li>Resource-based policy misconfigurations</li>
        </ul>

        <h3>Специфічні атаки на Serverless</h3>

        <h4>Event Data Injection</h4>
        <p>Атакуючий маніпулює даними події, яка тригерить функцію:</p>
        <pre>
// S3 event injection
// Атакуючий створює файл з назвою: "; rm -rf /tmp/*; #.jpg"
exports.handler = async (event) => {
  const bucket = event.Records[0].s3.bucket.name;
  const key = event.Records[0].s3.object.key;
  // Вразливо!
  exec(`convert /tmp/${key} /tmp/thumbnail-${key}`);
};
        </pre>

        <h4>Poisoned Function</h4>
        <p>Експлуатація warm containers — код зберігається між викликами:</p>
        <ul>
          <li>Атакуючий модифікує глобальні змінні</li>
          <li>Впливає на наступні виклики того ж контейнера</li>
          <li>Важко виявити — залежить від того, який контейнер обробить запит</li>
        </ul>

        <h4>Cross-Tenant Attacks</h4>
        <p>В multi-tenant середовищі можливі атаки між клієнтами:</p>
        <ul>
          <li>Side-channel attacks на shared infrastructure</li>
          <li>Timing attacks</li>
          <li>Resource exhaustion, що впливає на сусідів</li>
        </ul>

        <h3>Реальні інциденти</h3>

        <h4>Capital One Breach (2019)</h4>
        <p>Один з найбільших cloud breaches був пов'язаний з serverless:</p>
        <ul>
          <li>WAF misconfiguration дозволив SSRF атаку</li>
          <li>Lambda функція мала занадто широкі IAM права</li>
          <li>Атакуючий отримав доступ до metadata service</li>
          <li>Вкрадено дані 100+ мільйонів клієнтів</li>
          <li><strong>Урок:</strong> Principle of Least Privilege критичний</li>
        </ul>
      </section>

      <section>
        <h2>5.3 Технології ізоляції</h2>

        <h3>Проблема Multi-tenancy</h3>
        <p>Serverless платформи виконують код від тисяч різних клієнтів на спільній інфраструктурі. Це створює критичну потребу в сильній ізоляції.</p>

        <p>Традиційні контейнери (Docker) не забезпечують достатньої ізоляції для multi-tenant serverless:</p>
        <ul>
          <li>Спільне ядро — вразливість ядра = компрометація всіх</li>
          <li>Container escape можливий</li>
          <li>Не призначені для недовірених workloads</li>
        </ul>

        <h3>AWS Firecracker</h3>
        <p><strong>Firecracker</strong> — це lightweight Virtual Machine Monitor (VMM), розроблений AWS для serverless workloads. Він поєднує безпеку VM з швидкістю контейнерів.</p>

        <h4>Ключові характеристики</h4>
        <ul>
          <li><strong>microVM:</strong> мінімальна VM з власним ядром</li>
          <li><strong>Швидкість:</strong> cold start < 125ms</li>
          <li><strong>Мінімальний footprint:</strong> ~5MB RAM overhead</li>
          <li><strong>Security-first design:</strong> мінімальна поверхня атаки</li>
          <li><strong>Написаний на Rust:</strong> memory safety</li>
        </ul>

        <h4>Архітектура Firecracker</h4>
        <pre>
┌─────────────────────────────────────────────┐
│              Host Machine                    │
│  ┌─────────────┐  ┌─────────────┐           │
│  │  microVM 1  │  │  microVM 2  │  ...      │
│  │ ┌─────────┐ │  │ ┌─────────┐ │           │
│  │ │ Lambda  │ │  │ │ Lambda  │ │           │
│  │ │ Function│ │  │ │ Function│ │           │
│  │ └─────────┘ │  │ └─────────┘ │           │
│  │   Guest OS  │  │   Guest OS  │           │
│  │   (Linux)   │  │   (Linux)   │           │
│  └──────┬──────┘  └──────┬──────┘           │
│         │                │                   │
│  ┌──────┴────────────────┴──────┐           │
│  │        Firecracker VMM        │           │
│  └──────────────┬────────────────┘           │
│                 │                            │
│  ┌──────────────┴────────────────┐           │
│  │           Host Kernel          │           │
│  └────────────────────────────────┘           │
└─────────────────────────────────────────────┘
        </pre>

        <h4>Безпека Firecracker</h4>
        <ul>
          <li><strong>Кожна функція в окремій VM:</strong> повна ізоляція ядра</li>
          <li><strong>Jailer:</strong> додатковий рівень sandboxing</li>
          <li><strong>Seccomp filters:</strong> обмеження системних викликів</li>
          <li><strong>Мінімальний device model:</strong> тільки virtio-net, virtio-block</li>
          <li><strong>No hardware passthrough:</strong> немає доступу до фізичних пристроїв</li>
        </ul>

        <h4>Використання</h4>
        <ul>
          <li><strong>AWS Lambda:</strong> основна технологія ізоляції</li>
          <li><strong>AWS Fargate:</strong> для контейнерів</li>
          <li><strong>Open Source:</strong> можна використовувати самостійно</li>
        </ul>

        <h3>Google gVisor</h3>
        <p><strong>gVisor</strong> — це application kernel від Google, який забезпечує ізоляцію через перехоплення системних викликів.</p>

        <h4>Архітектура gVisor</h4>
        <pre>
┌─────────────────────────────────────────────┐
│              Container                       │
│  ┌─────────────────────────────────────┐    │
│  │           Application                │    │
│  └──────────────┬──────────────────────┘    │
│                 │ syscalls                   │
│  ┌──────────────┴──────────────────────┐    │
│  │             Sentry                   │    │
│  │      (User-space Kernel)             │    │
│  └──────────────┬──────────────────────┘    │
│                 │ limited syscalls          │
│  ┌──────────────┴──────────────────────┐    │
│  │             Gofer                    │    │
│  │      (File System Proxy)             │    │
│  └──────────────┬──────────────────────┘    │
└─────────────────┼───────────────────────────┘
                  │
┌─────────────────┴───────────────────────────┐
│              Host Kernel                     │
└─────────────────────────────────────────────┘
        </pre>

        <h4>Компоненти gVisor</h4>
        <ul>
          <li><strong>Sentry:</strong> User-space kernel, що реалізує Linux syscall interface</li>
          <li><strong>Gofer:</strong> File system proxy для доступу до файлів</li>
          <li><strong>runsc:</strong> OCI-compatible container runtime</li>
        </ul>

        <h4>Безпека gVisor</h4>
        <ul>
          <li><strong>Reduced attack surface:</strong> application не має прямого доступу до host kernel</li>
          <li><strong>Defense in depth:</strong> навіть якщо Sentry компрометований, host kernel захищений</li>
          <li><strong>Seccomp:</strong> обмежений набір syscalls до host</li>
          <li><strong>Написаний на Go:</strong> memory safety</li>
        </ul>

        <h4>Обмеження</h4>
        <ul>
          <li>Не всі syscalls підтримані (близько 70%)</li>
          <li>Performance overhead (особливо I/O)</li>
          <li>Деякі додатки можуть не працювати</li>
        </ul>

        <h4>Використання</h4>
        <ul>
          <li><strong>Google Cloud Run:</strong> опція sandboxed containers</li>
          <li><strong>GKE Sandbox:</strong> для Kubernetes pods</li>
          <li><strong>Open Source:</strong> можна інтегрувати з Docker/Kubernetes</li>
        </ul>

        <h3>Kata Containers</h3>
        <p><strong>Kata Containers</strong> — проект, що поєднує легкість контейнерів з безпекою VM.</p>

        <h4>Ключові особливості</h4>
        <ul>
          <li>Кожен контейнер/pod в окремій lightweight VM</li>
          <li>OCI-compatible runtime</li>
          <li>Підтримує різні гіпервізори (QEMU, Firecracker, Cloud Hypervisor)</li>
          <li>Інтеграція з Kubernetes через CRI</li>
        </ul>

        <h4>Порівняння</h4>
        <table>
          <tr>
            <th>Характеристика</th>
            <th>Firecracker</th>
            <th>gVisor</th>
            <th>Kata</th>
          </tr>
          <tr>
            <td>Тип ізоляції</td>
            <td>microVM</td>
            <td>User-space kernel</td>
            <td>Lightweight VM</td>
          </tr>
          <tr>
            <td>Cold start</td>
            <td>~125ms</td>
            <td>~150ms</td>
            <td>~500ms</td>
          </tr>
          <tr>
            <td>Memory overhead</td>
            <td>~5MB</td>
            <td>~50MB</td>
            <td>~100MB</td>
          </tr>
          <tr>
            <td>Compatibility</td>
            <td>Висока</td>
            <td>Середня (~70%)</td>
            <td>Висока</td>
          </tr>
          <tr>
            <td>Використовується</td>
            <td>AWS Lambda</td>
            <td>GCP Cloud Run</td>
            <td>OpenStack, Kubernetes</td>
          </tr>
        </table>

        <h3>Cloudflare Workers: V8 Isolates</h3>
        <p>Cloudflare використовує інший підхід — <strong>V8 Isolates</strong>:</p>
        <ul>
          <li>JavaScript/WASM виконується в ізольованих V8 contexts</li>
          <li>Не потрібні контейнери чи VM</li>
          <li>Надзвичайно швидкий cold start (< 5ms)</li>
          <li>Менший overhead</li>
          <li>Обмеження: тільки JavaScript/WASM</li>
        </ul>
      </section>

      <section>
        <h2>5.4 Best Practices безпеки Serverless</h2>

        <h3>Principle of Least Privilege</h3>
        <p>Найважливіший принцип для serverless — кожна функція має мати мінімально необхідні права.</p>

        <pre>
# Погано — занадто широкі права
{
  "Effect": "Allow",
  "Action": "s3:*",
  "Resource": "*"
}

# Добре — конкретні права на конкретний ресурс
{
  "Effect": "Allow",
  "Action": ["s3:GetObject"],
  "Resource": "arn:aws:s3:::my-bucket/uploads/*"
}
        </pre>

        <h4>Рекомендації IAM</h4>
        <ul>
          <li>Окрема IAM role для кожної функції</li>
          <li>Використовуйте resource-based conditions</li>
          <li>Регулярно аудитуйте permissions</li>
          <li>Використовуйте AWS IAM Access Analyzer</li>
        </ul>

        <h3>Secure Dependencies</h3>
        <ul>
          <li><strong>Мінімізуйте залежності:</strong> менше коду = менша поверхня атаки</li>
          <li><strong>Скануйте на вразливості:</strong> npm audit, pip-audit, Snyk</li>
          <li><strong>Lock versions:</strong> package-lock.json, requirements.txt з версіями</li>
          <li><strong>Регулярні оновлення:</strong> автоматизуйте через Dependabot</li>
        </ul>

        <h3>Input Validation</h3>
        <pre>
// Валідація вхідних даних
exports.handler = async (event) => {
  // Валідуйте та санітизуйте всі inputs
  const userId = event.pathParameters?.userId;

  if (!userId || !/^[a-zA-Z0-9-]+$/.test(userId)) {
    return {
      statusCode: 400,
      body: JSON.stringify({ error: 'Invalid user ID' })
    };
  }

  // Безпечно використовуйте після валідації
  const user = await getUser(userId);
  // ...
};
        </pre>

        <h3>Secrets Management</h3>
        <ul>
          <li><strong>Не в коді:</strong> ніколи не hardcode секрети</li>
          <li><strong>Не в environment variables:</strong> для чутливих даних</li>
          <li><strong>AWS Secrets Manager:</strong> або SSM Parameter Store</li>
          <li><strong>Runtime retrieval:</strong> отримуйте секрети при виконанні</li>
        </ul>

        <pre>
// Отримання секрету з AWS Secrets Manager
const { SecretsManagerClient, GetSecretValueCommand } = require("@aws-sdk/client-secrets-manager");

const client = new SecretsManagerClient();

let cachedSecret = null;

async function getSecret() {
  if (cachedSecret) return cachedSecret;

  const command = new GetSecretValueCommand({
    SecretId: "my-app/database-credentials"
  });

  const response = await client.send(command);
  cachedSecret = JSON.parse(response.SecretString);
  return cachedSecret;
}
        </pre>

        <h3>Logging та Monitoring</h3>
        <ul>
          <li><strong>Structured logging:</strong> JSON формат для easy parsing</li>
          <li><strong>Correlation IDs:</strong> трасування через distributed system</li>
          <li><strong>Не логуйте sensitive data:</strong> паролі, tokens, PII</li>
          <li><strong>Централізований logging:</strong> CloudWatch, Datadog</li>
        </ul>

        <pre>
// Structured logging з correlation ID
exports.handler = async (event, context) => {
  const correlationId = event.headers?.['x-correlation-id'] || context.awsRequestId;

  console.log(JSON.stringify({
    level: 'INFO',
    correlationId,
    message: 'Processing request',
    userId: event.pathParameters?.userId,
    // НЕ логуємо sensitive data!
  }));

  // ...
};
        </pre>

        <h3>API Gateway Security</h3>
        <ul>
          <li><strong>Authentication:</strong> Cognito, Lambda Authorizers</li>
          <li><strong>Rate Limiting:</strong> захист від DoS</li>
          <li><strong>WAF:</strong> захист від common attacks</li>
          <li><strong>Request validation:</strong> на рівні API Gateway</li>
          <li><strong>CORS:</strong> правильна конфігурація</li>
        </ul>

        <h3>Function Configuration</h3>
        <ul>
          <li><strong>Timeout:</strong> встановіть розумний timeout (не максимальний)</li>
          <li><strong>Memory:</strong> right-size пам'ять</li>
          <li><strong>Concurrency limits:</strong> захист від runaway costs</li>
          <li><strong>Reserved concurrency:</strong> для critical functions</li>
          <li><strong>Dead Letter Queue:</strong> для failed invocations</li>
        </ul>

        <h3>Network Security</h3>
        <ul>
          <li><strong>VPC:</strong> розміщуйте функції у VPC для доступу до internal resources</li>
          <li><strong>VPC Endpoints:</strong> private access до AWS сервісів</li>
          <li><strong>Security Groups:</strong> обмежуйте outbound traffic</li>
          <li><strong>НЕ в VPC:</strong> якщо не потрібен доступ до VPC resources (швидший cold start)</li>
        </ul>

        <h3>CI/CD Security</h3>
        <ul>
          <li><strong>Infrastructure as Code:</strong> SAM, Serverless Framework, Terraform</li>
          <li><strong>Policy-as-Code:</strong> AWS Config Rules, OPA</li>
          <li><strong>Automated scanning:</strong> в CI/CD pipeline</li>
          <li><strong>Staging environments:</strong> тестування перед production</li>
        </ul>

        <h3>Serverless Security Checklist</h3>
        <ul>
          <li>☐ Окрема IAM role для кожної функції</li>
          <li>☐ Least privilege permissions</li>
          <li>☐ Input validation на всіх endpoints</li>
          <li>☐ Secrets в Secrets Manager, не в env vars</li>
          <li>☐ Залежності скановані на вразливості</li>
          <li>☐ Structured logging без sensitive data</li>
          <li>☐ API Gateway з authentication та rate limiting</li>
          <li>☐ Timeouts та concurrency limits встановлені</li>
          <li>☐ VPC тільки якщо необхідно</li>
          <li>☐ Моніторинг та алерти налаштовані</li>
        </ul>
      </section>

      <section>
        <h2>Висновки</h2>
        <p>Serverless змінює парадигму розробки та безпеки. Хоча провайдер бере на себе більше відповідальності за інфраструктуру, нові виклики виникають на рівні коду, конфігурації та архітектури.</p>

        <h3>Ключові тези</h3>
        <ul>
          <li><strong>Serverless ≠ No Security:</strong> відповідальність зміщується, але не зникає</li>
          <li><strong>Least Privilege критичний:</strong> Capital One breach — яскравий приклад</li>
          <li><strong>Event-driven = нові вектори:</strong> Event Data Injection, Poisoned Functions</li>
          <li><strong>Ізоляція еволюціонує:</strong> Firecracker, gVisor забезпечують безпеку multi-tenancy</li>
          <li><strong>Observability складніша:</strong> distributed systems потребують distributed tracing</li>
        </ul>

        <h3>Тренди</h3>
        <ul>
          <li>Edge computing (Cloudflare Workers, Lambda@Edge)</li>
          <li>WebAssembly для portable serverless</li>
          <li>Serverless containers (Cloud Run, Fargate)</li>
          <li>AI/ML serverless (SageMaker Serverless)</li>
        </ul>
      </section>

      <section>
        <h2>Питання для самоперевірки</h2>
        <ol>
          <li>Чим відрізняється FaaS від BaaS?</li>
          <li>Що таке cold start і як його мінімізувати?</li>
          <li>Які специфічні загрози характерні для serverless (OWASP Serverless Top 10)?</li>
          <li>Як Firecracker забезпечує ізоляцію між функціями?</li>
          <li>У чому різниця між підходами Firecracker та gVisor?</li>
          <li>Чому не варто зберігати секрети в environment variables?</li>
          <li>Як Capital One breach пов'язаний з serverless?</li>
          <li>Які best practices IAM для Lambda функцій?</li>
        </ol>
      </section>

    </article>

    <footer id="footer"></footer>
  </main>

  <script src="../js/main.js"></script>

</body>
</html>
