<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Конспект лекції 4: Безпека віртуалізації та контейнеризації.">
  <meta name="author" content="Кафедра ТЕІБ, Ужгородський національний університет">
  <meta name="theme-color" content="#0ea5e9">
  <title>Конспект лекції 4 — Безпека хмарних технологій</title>
  <link rel="icon" type="image/svg+xml" href="../../img/favicon.svg">
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../css/style.css">
  <link rel="stylesheet" href="../../css/print.css" media="print">
  <script>
    if (localStorage.getItem('theme') === 'dark') {
      document.documentElement.classList.add('dark');
    }
  </script>
</head>
<body>

  <aside>
    <div class="logo">
      <div class="logo-icon">
        <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/>
          <path d="M12 13v-1a2 2 0 0 1 2-2h0a2 2 0 0 1 2 2v1"/>
          <rect x="10" y="13" width="8" height="5" rx="1"/>
        </svg>
      </div>
      <div class="logo-text">
        Безпека<br>хмарних технологій
        <span>онлайн-курс</span>
      </div>
    </div>

    <nav>
      <a href="../../index.html" class="active">
        <span class="nav-icon"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg></span>
        Лекції
      </a>
      <a href="../../practicals.html">
        <span class="nav-icon"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg></span>
        Семінари
      </a>
      <a href="../../tests.html">
        <span class="nav-icon"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></span>
        Тести
      </a>
      <a href="../../materials.html">
        <span class="nav-icon"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/></svg></span>
        Матеріали
      </a>
    </nav>

    <div class="sidebar-footer">
      <button class="theme-toggle" onclick="toggleTheme()" aria-label="Перемкнути тему">
        <svg id="theme-icon" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" aria-hidden="true"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
        <span id="theme-label">Темна тема</span>
      </button>
    </div>
  </aside>

  <main>
    <div class="lecture-nav-top">
      <a href="../../lecture.html?id=4" class="back-link">← Назад до лекції</a>
      <span class="lecture-badge">Конспект</span>
    </div>

    <article class="lecture-content">
      <h1>Лекція 4. Безпека віртуалізації та контейнеризації</h1>
      <div class="lecture-info">
        <span><svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2" style="vertical-align: -2px; margin-right: 4px;"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>2 год</span>
      </div>

      <section>
        <h2>Вступ</h2>
        <p>Сьогодні ми поговоримо про технології, які лежать в основі хмарних обчислень — віртуалізацію та контейнеризацію. Без цих технологій хмара в її сучасному вигляді просто не існувала б. Але разом із потужними можливостями вони приносять і специфічні безпекові виклики.</p>

        <p>Віртуалізація дозволяє запускати кілька операційних систем на одному фізичному сервері. Контейнеризація йде далі — вона дозволяє ізолювати окремі додатки та їхні залежності. Обидві технології критично залежать від правильної конфігурації для забезпечення безпеки.</p>

        <p>У цій лекції ми розглянемо загрози для гіпервізорів та віртуальних машин, детально вивчимо безпеку Docker та Kubernetes, а також познайомимося з категорією інструментів CWPP (Cloud Workload Protection Platform), які допомагають захищати робочі навантаження в хмарі.</p>

        <h3>Чому це важливо?</h3>
        <p>Статистика показує, що більшість інцидентів безпеки в хмарі пов'язані не з вразливостями самих технологій, а з неправильною конфігурацією. Неправильно налаштований Docker container, занадто широкі права в Kubernetes, незахищений гіпервізор — все це створює вектори атаки, які активно експлуатуються зловмисниками.</p>

        <h3>Цілі лекції</h3>
        <p>Після цієї лекції ви зможете:</p>
        <ul>
          <li>Пояснити архітектуру та типи гіпервізорів, їхні безпекові особливості</li>
          <li>Ідентифікувати основні загрози для віртуалізованих середовищ (VM escape, side-channel attacks)</li>
          <li>Застосовувати best practices безпеки Docker: захист образів, Dockerfile, runtime</li>
          <li>Налаштовувати безпеку Kubernetes: RBAC, Network Policies, Pod Security Standards</li>
          <li>Розуміти роль та можливості CWPP у захисті хмарних workloads</li>
          <li>Застосовувати принципи supply chain security для контейнерних середовищ</li>
        </ul>

        <h3>Структура лекції</h3>
        <p>Ми рухатимемося від фундаменту до практики: спочатку віртуалізація (базовий рівень ізоляції), потім Docker (контейнерна ізоляція), далі Kubernetes (оркестрація контейнерів), CWPP (інструменти захисту), і нарешті — supply chain security (захист ланцюга постачання). Кожен рівень додає нові можливості, але й нові вектори атак.</p>
      </section>

      <section>
        <h2>4.1 Безпека віртуалізації</h2>

        <h3>Що таке віртуалізація?</h3>
        <p>Віртуалізація — це технологія, яка дозволяє створювати віртуальні версії фізичних ресурсів: серверів, сховищ, мереж. У контексті хмарних обчислень найчастіше мова йде про серверну віртуалізацію — можливість запускати кілька віртуальних машин (VM) на одному фізичному сервері.</p>

        <p>Ключовий компонент віртуалізації — <strong>гіпервізор</strong> (hypervisor), також відомий як Virtual Machine Monitor (VMM). Гіпервізор — це програмне забезпечення, яке керує віртуальними машинами та розподіляє фізичні ресурси між ними.</p>

        <h3>Типи гіпервізорів</h3>

        <h4>Тип 1: Bare-metal гіпервізори</h4>
        <p>Встановлюються безпосередньо на апаратне забезпечення, без операційної системи-посередника:</p>
        <ul>
          <li><strong>VMware ESXi</strong> — найпопулярніший enterprise-гіпервізор</li>
          <li><strong>Microsoft Hyper-V</strong> — вбудований у Windows Server</li>
          <li><strong>Xen</strong> — open-source, використовується AWS</li>
          <li><strong>KVM</strong> — вбудований у ядро Linux, використовується GCP</li>
        </ul>
        <p><strong>Переваги:</strong> вища продуктивність, менша поверхня атаки (немає host OS).</p>

        <h4>Тип 2: Hosted гіпервізори</h4>
        <p>Працюють поверх звичайної операційної системи:</p>
        <ul>
          <li><strong>VMware Workstation/Fusion</strong></li>
          <li><strong>Oracle VirtualBox</strong></li>
          <li><strong>Parallels Desktop</strong></li>
        </ul>
        <p><strong>Використання:</strong> переважно для розробки та тестування, не для production.</p>

        <h3>Загрози для віртуалізованих середовищ</h3>

        <h4>VM Escape (Втеча з VM)</h4>
        <p>Найнебезпечніша загроза — це можливість атакуючого "вирватися" з віртуальної машини та отримати доступ до гіпервізора або інших VM на тому ж хості.</p>

        <p><strong>Історичні приклади:</strong></p>
        <ul>
          <li><strong>CVE-2017-4902 (VMware):</strong> вразливість у SVGA-драйвері дозволяла VM escape</li>
          <li><strong>VENOM (CVE-2015-3456):</strong> вразливість у віртуальному floppy-контролері QEMU, що впливала на Xen та KVM</li>
          <li><strong>Cloudburst:</strong> одна з перших демонстрацій VM escape на VMware</li>
        </ul>

        <p><strong>Захист:</strong></p>
        <ul>
          <li>Регулярне оновлення гіпервізора та VM tools</li>
          <li>Мінімізація віртуального hardware (відключення непотрібних пристроїв)</li>
          <li>Використання nested virtualization з обережністю</li>
        </ul>

        <h4>Side-Channel Attacks</h4>
        <p>Атаки, які експлуатують спільне використання фізичних ресурсів (CPU cache, пам'ять) різними VM:</p>

        <ul>
          <li><strong>Spectre/Meltdown (2018):</strong> Вразливості в процесорах Intel/AMD, що дозволяли читати пам'ять інших процесів та VM через speculative execution</li>
          <li><strong>L1TF (L1 Terminal Fault):</strong> Дозволяла читати дані з L1 cache інших VM</li>
          <li><strong>MDS (Microarchitectural Data Sampling):</strong> Сімейство атак на буфери процесора</li>
        </ul>

        <p><strong>Захист:</strong></p>
        <ul>
          <li>Оновлення мікрокоду процесора та патчі ОС</li>
          <li>Для критичних workloads — dedicated hosts (без multi-tenancy)</li>
          <li>Моніторинг Hyper-Threading налаштувань</li>
        </ul>

        <h4>Hyperjacking</h4>
        <p>Атака, при якій зловмисник встановлює шкідливий гіпервізор під легітимну систему:</p>
        <ul>
          <li>Оригінальна ОС стає "гостем" без її відома</li>
          <li>Атакуючий отримує повний контроль над системою</li>
          <li><strong>Blue Pill</strong> — концептуальний rootkit на базі AMD-V</li>
        </ul>

        <p><strong>Захист:</strong></p>
        <ul>
          <li>Secure Boot та UEFI</li>
          <li>TPM (Trusted Platform Module)</li>
          <li>Attestation механізми</li>
        </ul>

        <h4>Resource Exhaustion (Noisy Neighbor)</h4>
        <p>Одна VM споживає непропорційно багато ресурсів, впливаючи на інші VM на тому ж хості:</p>
        <ul>
          <li>CPU starvation</li>
          <li>Memory pressure</li>
          <li>I/O contention</li>
          <li>Network bandwidth exhaustion</li>
        </ul>

        <p><strong>Захист:</strong></p>
        <ul>
          <li>Resource quotas та limits</li>
          <li>Quality of Service (QoS) політики</li>
          <li>Proper capacity planning</li>
        </ul>

        <h3>Best Practices безпеки віртуалізації</h3>

        <h4>Захист гіпервізора</h4>
        <ul>
          <li><strong>Мінімальна інсталяція:</strong> тільки необхідні компоненти</li>
          <li><strong>Окрема management network:</strong> ізоляція управління від production-трафіку</li>
          <li><strong>Сильна автентифікація:</strong> MFA для доступу до management console</li>
          <li><strong>Регулярні оновлення:</strong> патчі безпеки без затримок</li>
          <li><strong>Logging та monitoring:</strong> централізований збір логів</li>
        </ul>

        <h4>Захист віртуальних машин</h4>
        <ul>
          <li><strong>Hardening:</strong> CIS Benchmarks для guest OS</li>
          <li><strong>Encrypted VMs:</strong> шифрування дисків VM</li>
          <li><strong>Snapshot management:</strong> безпечне зберігання та видалення</li>
          <li><strong>VM templates:</strong> стандартизовані захищені образи</li>
        </ul>

        <h4>Network security</h4>
        <ul>
          <li><strong>Virtual switches:</strong> ізоляція мережевого трафіку</li>
          <li><strong>VLAN tagging:</strong> сегментація на рівні мережі</li>
          <li><strong>Distributed firewalls:</strong> мікросегментація (NSX, ACI)</li>
        </ul>

        <table>
          <tr>
            <th>Загроза</th>
            <th>Вплив</th>
            <th>Основний захист</th>
          </tr>
          <tr>
            <td>VM Escape</td>
            <td>Критичний — доступ до гіпервізора</td>
            <td>Патчі, мінімальний hardware</td>
          </tr>
          <tr>
            <td>Side-Channel</td>
            <td>Високий — витік даних</td>
            <td>Мікрокод, dedicated hosts</td>
          </tr>
          <tr>
            <td>Hyperjacking</td>
            <td>Критичний — повний контроль</td>
            <td>Secure Boot, TPM</td>
          </tr>
          <tr>
            <td>Noisy Neighbor</td>
            <td>Середній — DoS</td>
            <td>Resource limits, QoS</td>
          </tr>
        </table>

        <!-- Diagram: Hypervisor Architecture -->
        <div class="diagram">
          <div class="diagram-title">Архітектура гіпервізорів: Type 1 vs Type 2</div>
          <svg viewBox="0 0 700 260" xmlns="http://www.w3.org/2000/svg">
            <!-- Type 1: Bare-metal -->
            <text class="diagram-text-bold" x="175" y="25" text-anchor="middle">Type 1: Bare-metal Hypervisor</text>

            <!-- Hardware -->
            <rect fill="#64748b" x="30" y="200" width="290" height="40" rx="6"/>
            <text fill="white" x="175" y="225" text-anchor="middle" font-size="12">Hardware (CPU, RAM, Storage)</text>

            <!-- Type 1 Hypervisor -->
            <rect fill="#8b5cf6" x="30" y="150" width="290" height="45" rx="6"/>
            <text fill="white" x="175" y="178" text-anchor="middle" font-size="12">Type 1 Hypervisor (ESXi, Xen, KVM)</text>

            <!-- VMs on Type 1 -->
            <g transform="translate(45, 50)">
              <rect fill="#dbeafe" stroke="#3b82f6" stroke-width="2" x="0" y="0" width="80" height="95" rx="6"/>
              <rect fill="#bfdbfe" x="8" y="8" width="64" height="25" rx="3"/>
              <text fill="#1e3a8a" x="40" y="26" text-anchor="middle" font-size="9">Guest OS</text>
              <rect fill="var(--card)" stroke="var(--card-border)" x="8" y="38" width="30" height="25" rx="3"/>
              <text fill="var(--text)" x="23" y="55" text-anchor="middle" font-size="8">App</text>
              <rect fill="var(--card)" stroke="var(--card-border)" x="42" y="38" width="30" height="25" rx="3"/>
              <text fill="var(--text)" x="57" y="55" text-anchor="middle" font-size="8">App</text>
              <text fill="#1d4ed8" x="40" y="82" text-anchor="middle" font-size="9">VM 1</text>
            </g>

            <g transform="translate(135, 50)">
              <rect fill="#dbeafe" stroke="#3b82f6" stroke-width="2" x="0" y="0" width="80" height="95" rx="6"/>
              <rect fill="#bfdbfe" x="8" y="8" width="64" height="25" rx="3"/>
              <text fill="#1e3a8a" x="40" y="26" text-anchor="middle" font-size="9">Guest OS</text>
              <rect fill="var(--card)" stroke="var(--card-border)" x="8" y="38" width="64" height="25" rx="3"/>
              <text fill="var(--text)" x="40" y="55" text-anchor="middle" font-size="8">Application</text>
              <text fill="#1d4ed8" x="40" y="82" text-anchor="middle" font-size="9">VM 2</text>
            </g>

            <g transform="translate(225, 50)">
              <rect fill="#dbeafe" stroke="#3b82f6" stroke-width="2" x="0" y="0" width="80" height="95" rx="6"/>
              <rect fill="#bfdbfe" x="8" y="8" width="64" height="25" rx="3"/>
              <text fill="#1e3a8a" x="40" y="26" text-anchor="middle" font-size="9">Guest OS</text>
              <rect fill="var(--card)" stroke="var(--card-border)" x="8" y="38" width="64" height="25" rx="3"/>
              <text fill="var(--text)" x="40" y="55" text-anchor="middle" font-size="8">Application</text>
              <text fill="#1d4ed8" x="40" y="82" text-anchor="middle" font-size="9">VM 3</text>
            </g>

            <!-- Type 2: Hosted -->
            <text class="diagram-text-bold" x="525" y="25" text-anchor="middle">Type 2: Hosted Hypervisor</text>

            <!-- Hardware -->
            <rect fill="#64748b" x="380" y="200" width="290" height="40" rx="6"/>
            <text fill="white" x="525" y="225" text-anchor="middle" font-size="12">Hardware (CPU, RAM, Storage)</text>

            <!-- Host OS -->
            <rect fill="#475569" x="380" y="150" width="290" height="45" rx="6"/>
            <text fill="white" x="525" y="178" text-anchor="middle" font-size="12">Host OS (Windows, macOS, Linux)</text>

            <!-- Type 2 Hypervisor -->
            <rect fill="#8b5cf6" x="380" y="105" width="290" height="40" rx="6"/>
            <text fill="white" x="525" y="130" text-anchor="middle" font-size="11">Type 2 Hypervisor (VirtualBox, VMware Workstation)</text>

            <!-- VMs on Type 2 -->
            <g transform="translate(400, 45)">
              <rect fill="#dbeafe" stroke="#3b82f6" stroke-width="2" x="0" y="0" width="75" height="55" rx="6"/>
              <text fill="#1d4ed8" x="37" y="20" text-anchor="middle" font-size="9">Guest OS</text>
              <text fill="#1d4ed8" x="37" y="35" text-anchor="middle" font-size="9">+ Apps</text>
              <text fill="#1d4ed8" x="37" y="50" text-anchor="middle" font-size="8">VM 1</text>
            </g>

            <g transform="translate(487, 45)">
              <rect fill="#dbeafe" stroke="#3b82f6" stroke-width="2" x="0" y="0" width="75" height="55" rx="6"/>
              <text fill="#1d4ed8" x="37" y="20" text-anchor="middle" font-size="9">Guest OS</text>
              <text fill="#1d4ed8" x="37" y="35" text-anchor="middle" font-size="9">+ Apps</text>
              <text fill="#1d4ed8" x="37" y="50" text-anchor="middle" font-size="8">VM 2</text>
            </g>

            <g transform="translate(575, 45)">
              <rect fill="#dbeafe" stroke="#3b82f6" stroke-width="2" x="0" y="0" width="75" height="55" rx="6"/>
              <text fill="#1d4ed8" x="37" y="20" text-anchor="middle" font-size="9">Guest OS</text>
              <text fill="#1d4ed8" x="37" y="35" text-anchor="middle" font-size="9">+ Apps</text>
              <text fill="#1d4ed8" x="37" y="50" text-anchor="middle" font-size="8">VM 3</text>
            </g>
          </svg>
          <div class="diagram-caption">Рис. 4.1b. Type 1 гіпервізор працює напряму на hardware (вища безпека), Type 2 — поверх Host OS (більша атакова поверхня)</div>
        </div>

        <h3>Детальний аналіз Side-Channel атак</h3>
        <p>Side-channel атаки експлуатують фізичні характеристики системи, а не логічні вразливості в коді. У віртуалізованих середовищах вони особливо небезпечні через спільне використання ресурсів.</p>

        <h4>Типи Side-Channel атак у віртуалізації</h4>
        <table>
          <tr>
            <th>Атака</th>
            <th>CVE</th>
            <th>Механізм</th>
            <th>Вплив</th>
          </tr>
          <tr>
            <td><strong>Spectre</strong></td>
            <td>CVE-2017-5753/5715</td>
            <td>Speculative execution, branch prediction</td>
            <td>Читання пам'яті інших процесів/VM</td>
          </tr>
          <tr>
            <td><strong>Meltdown</strong></td>
            <td>CVE-2017-5754</td>
            <td>Out-of-order execution</td>
            <td>Читання kernel memory з userspace</td>
          </tr>
          <tr>
            <td><strong>L1TF</strong></td>
            <td>CVE-2018-3646</td>
            <td>L1 cache speculation</td>
            <td>Читання L1 cache інших VM</td>
          </tr>
          <tr>
            <td><strong>MDS</strong></td>
            <td>CVE-2018-12126/7</td>
            <td>Microarchitectural buffers</td>
            <td>Читання даних з CPU buffers</td>
          </tr>
          <tr>
            <td><strong>RIDL</strong></td>
            <td>CVE-2019-11091</td>
            <td>Load port data sampling</td>
            <td>Витік даних між hyper-threads</td>
          </tr>
        </table>

        <h4>Захист від Side-Channel атак</h4>
        <pre>
# Перевірка мітигацій на Linux
cat /sys/devices/system/cpu/vulnerabilities/*

# Типовий вивід:
spectre_v1: Mitigation: usercopy/swapgs barriers and __user pointer sanitization
spectre_v2: Mitigation: Retpolines, IBPB: conditional, STIBP: conditional, RSB filling
meltdown: Mitigation: PTI
l1tf: Mitigation: PTE Inversion; VMX: conditional cache flushes, SMT vulnerable
mds: Mitigation: Clear CPU buffers; SMT vulnerable
        </pre>

        <ul>
          <li><strong>Microcode updates:</strong> Регулярне оновлення мікрокоду процесора</li>
          <li><strong>Kernel patches:</strong> KPTI (Kernel Page Table Isolation) для Meltdown</li>
          <li><strong>Retpolines:</strong> Компіляторна техніка проти Spectre v2</li>
          <li><strong>SMT/HT disable:</strong> Вимкнення Hyper-Threading для критичних workloads</li>
          <li><strong>Dedicated hosts:</strong> Виділені фізичні сервери без multi-tenancy</li>
        </ul>
      </section>

      <section>
        <h2>4.2 Безпека Docker</h2>

        <h3>Що таке контейнеризація?</h3>
        <p>Контейнеризація — це легка форма віртуалізації на рівні операційної системи. На відміну від VM, контейнери не емулюють повну операційну систему — вони використовують ядро хост-системи, ізолюючи лише простір користувача (userspace).</p>

        <p><strong>Docker</strong> — найпопулярніша платформа контейнеризації, яка стала де-факто стандартом. Docker використовує механізми ядра Linux для ізоляції:</p>
        <ul>
          <li><strong>Namespaces:</strong> ізоляція процесів, мережі, файлової системи, користувачів</li>
          <li><strong>Cgroups (Control Groups):</strong> обмеження ресурсів (CPU, пам'ять, I/O)</li>
          <li><strong>Union File Systems:</strong> layered file system для ефективного зберігання</li>
        </ul>

        <h3>Контейнери vs Віртуальні машини</h3>

        <!-- Diagram: VMs vs Containers -->
        <div class="diagram">
          <div class="diagram-title">Віртуальні машини vs Контейнери: архітектурне порівняння</div>
          <svg viewBox="0 0 700 280" xmlns="http://www.w3.org/2000/svg">
            <!-- VM Side -->
            <text class="diagram-text-bold" x="175" y="25" text-anchor="middle">Віртуальні машини</text>

            <!-- Hardware -->
            <rect fill="#64748b" x="30" y="230" width="290" height="35" rx="4"/>
            <text fill="white" x="175" y="252" text-anchor="middle" font-size="12">Hardware</text>

            <!-- Host OS -->
            <rect fill="#475569" x="30" y="190" width="290" height="35" rx="4"/>
            <text fill="white" x="175" y="212" text-anchor="middle" font-size="12">Host OS</text>

            <!-- Hypervisor -->
            <rect fill="#8b5cf6" x="30" y="150" width="290" height="35" rx="4"/>
            <text fill="white" x="175" y="172" text-anchor="middle" font-size="12">Hypervisor</text>

            <!-- VM 1 -->
            <g transform="translate(40, 45)">
              <rect fill="#dbeafe" stroke="#3b82f6" stroke-width="2" x="0" y="0" width="85" height="100" rx="6"/>
              <rect fill="#93c5fd" x="8" y="8" width="69" height="25" rx="3"/>
              <text fill="#1e3a8a" x="42" y="26" text-anchor="middle" font-size="10">App A</text>
              <rect fill="#bfdbfe" x="8" y="38" width="69" height="25" rx="3"/>
              <text fill="#1e3a8a" x="42" y="56" text-anchor="middle" font-size="10">Bins/Libs</text>
              <rect fill="#60a5fa" x="8" y="68" width="69" height="25" rx="3"/>
              <text fill="white" x="42" y="86" text-anchor="middle" font-size="10">Guest OS</text>
            </g>

            <!-- VM 2 -->
            <g transform="translate(133, 45)">
              <rect fill="#dbeafe" stroke="#3b82f6" stroke-width="2" x="0" y="0" width="85" height="100" rx="6"/>
              <rect fill="#93c5fd" x="8" y="8" width="69" height="25" rx="3"/>
              <text fill="#1e3a8a" x="42" y="26" text-anchor="middle" font-size="10">App B</text>
              <rect fill="#bfdbfe" x="8" y="38" width="69" height="25" rx="3"/>
              <text fill="#1e3a8a" x="42" y="56" text-anchor="middle" font-size="10">Bins/Libs</text>
              <rect fill="#60a5fa" x="8" y="68" width="69" height="25" rx="3"/>
              <text fill="white" x="42" y="86" text-anchor="middle" font-size="10">Guest OS</text>
            </g>

            <!-- VM 3 -->
            <g transform="translate(226, 45)">
              <rect fill="#dbeafe" stroke="#3b82f6" stroke-width="2" x="0" y="0" width="85" height="100" rx="6"/>
              <rect fill="#93c5fd" x="8" y="8" width="69" height="25" rx="3"/>
              <text fill="#1e3a8a" x="42" y="26" text-anchor="middle" font-size="10">App C</text>
              <rect fill="#bfdbfe" x="8" y="38" width="69" height="25" rx="3"/>
              <text fill="#1e3a8a" x="42" y="56" text-anchor="middle" font-size="10">Bins/Libs</text>
              <rect fill="#60a5fa" x="8" y="68" width="69" height="25" rx="3"/>
              <text fill="white" x="42" y="86" text-anchor="middle" font-size="10">Guest OS</text>
            </g>

            <!-- Container Side -->
            <text class="diagram-text-bold" x="525" y="25" text-anchor="middle">Контейнери</text>

            <!-- Hardware -->
            <rect fill="#64748b" x="380" y="230" width="290" height="35" rx="4"/>
            <text fill="white" x="525" y="252" text-anchor="middle" font-size="12">Hardware</text>

            <!-- Host OS -->
            <rect fill="#475569" x="380" y="150" width="290" height="75" rx="4"/>
            <text fill="white" x="525" y="192" text-anchor="middle" font-size="12">Host OS (shared kernel)</text>

            <!-- Container Engine (Docker) -->
            <rect fill="#0ea5e9" x="380" y="110" width="290" height="35" rx="4"/>
            <text fill="white" x="525" y="132" text-anchor="middle" font-size="12">Container Engine (Docker)</text>

            <!-- Container 1 -->
            <g transform="translate(390, 45)">
              <rect fill="#dcfce7" stroke="#22c55e" stroke-width="2" x="0" y="0" width="65" height="60" rx="6"/>
              <rect fill="#86efac" x="6" y="8" width="53" height="20" rx="3"/>
              <text fill="#166534" x="32" y="23" text-anchor="middle" font-size="9">App A</text>
              <rect fill="#bbf7d0" x="6" y="32" width="53" height="20" rx="3"/>
              <text fill="#166534" x="32" y="47" text-anchor="middle" font-size="9">Bins/Libs</text>
            </g>

            <!-- Container 2 -->
            <g transform="translate(467, 45)">
              <rect fill="#dcfce7" stroke="#22c55e" stroke-width="2" x="0" y="0" width="65" height="60" rx="6"/>
              <rect fill="#86efac" x="6" y="8" width="53" height="20" rx="3"/>
              <text fill="#166534" x="32" y="23" text-anchor="middle" font-size="9">App B</text>
              <rect fill="#bbf7d0" x="6" y="32" width="53" height="20" rx="3"/>
              <text fill="#166534" x="32" y="47" text-anchor="middle" font-size="9">Bins/Libs</text>
            </g>

            <!-- Container 3 -->
            <g transform="translate(544, 45)">
              <rect fill="#dcfce7" stroke="#22c55e" stroke-width="2" x="0" y="0" width="65" height="60" rx="6"/>
              <rect fill="#86efac" x="6" y="8" width="53" height="20" rx="3"/>
              <text fill="#166534" x="32" y="23" text-anchor="middle" font-size="9">App C</text>
              <rect fill="#bbf7d0" x="6" y="32" width="53" height="20" rx="3"/>
              <text fill="#166534" x="32" y="47" text-anchor="middle" font-size="9">Bins/Libs</text>
            </g>

            <!-- Container 4 -->
            <g transform="translate(621, 45)">
              <rect fill="#dcfce7" stroke="#22c55e" stroke-width="2" x="0" y="0" width="40" height="60" rx="6"/>
              <text fill="#166534" x="20" y="35" text-anchor="middle" font-size="9">...</text>
            </g>

            <!-- VS divider -->
            <text fill="var(--text-secondary)" x="350" y="145" text-anchor="middle" font-size="20" font-weight="bold">vs</text>
          </svg>
          <div class="diagram-caption">Рис. 4.1. Архітектурна різниця: VM потребує Guest OS для кожного екземпляра, контейнери ділять ядро хоста</div>
        </div>

        <table>
          <tr>
            <th>Аспект</th>
            <th>Віртуальні машини</th>
            <th>Контейнери</th>
          </tr>
          <tr>
            <td>Ізоляція</td>
            <td>Повна (окреме ядро)</td>
            <td>Process-level (спільне ядро)</td>
          </tr>
          <tr>
            <td>Розмір</td>
            <td>GB (повна ОС)</td>
            <td>MB (тільки app + deps)</td>
          </tr>
          <tr>
            <td>Запуск</td>
            <td>Хвилини</td>
            <td>Секунди</td>
          </tr>
          <tr>
            <td>Overhead</td>
            <td>Значний</td>
            <td>Мінімальний</td>
          </tr>
          <tr>
            <td>Безпека</td>
            <td>Сильніша ізоляція</td>
            <td>Більша поверхня атаки</td>
          </tr>
        </table>

        <h3>Загрози безпеці Docker</h3>

        <h4>1. Вразливі базові образи</h4>
        <p>Контейнери будуються з базових образів, які можуть містити вразливості:</p>
        <ul>
          <li>Застарілі пакети з відомими CVE</li>
          <li>Malware в публічних образах</li>
          <li>Typosquatting — образи зі схожими назвами</li>
        </ul>

        <p><strong>Приклад:</strong> У 2018 році було виявлено 17 шкідливих образів на Docker Hub, які майнили криптовалюту. Вони були завантажені мільйони разів.</p>

        <h4>2. Container Escape</h4>
        <p>Аналог VM escape, але для контейнерів. Оскільки контейнери використовують спільне ядро, вразливість у ядрі може дозволити "втечу":</p>
        <ul>
          <li><strong>CVE-2019-5736 (runc):</strong> критична вразливість, що дозволяла перезаписати бінарник runc з контейнера</li>
          <li><strong>CVE-2020-15257:</strong> вразливість у containerd, що дозволяла доступ до host filesystem</li>
          <li><strong>Dirty COW (CVE-2016-5195):</strong> privilege escalation через вразливість ядра</li>
        </ul>

        <h4>3. Misconfiguration</h4>
        <p>Найчастіша причина інцидентів — неправильна конфігурація:</p>
        <ul>
          <li><strong>Privileged containers:</strong> контейнер з повними правами root на хості</li>
          <li><strong>Exposed Docker socket:</strong> доступ до /var/run/docker.sock дає повний контроль</li>
          <li><strong>Sensitive mounts:</strong> монтування критичних директорій хоста</li>
          <li><strong>Running as root:</strong> процеси всередині контейнера від root</li>
        </ul>

        <h4>4. Secrets Exposure</h4>
        <p>Витік секретів через образи та конфігурацію:</p>
        <ul>
          <li>API ключі в environment variables</li>
          <li>Паролі в Dockerfile (залишаються в layer history)</li>
          <li>Сертифікати та приватні ключі в образах</li>
        </ul>

        <h3>Best Practices безпеки Docker</h3>

        <h4>Безпека образів</h4>
        <pre>
# Погано
FROM ubuntu:latest

# Краще — конкретна версія
FROM ubuntu:22.04

# Найкраще — мінімальний образ
FROM alpine:3.18
# або distroless
FROM gcr.io/distroless/java17-debian11
        </pre>

        <ul>
          <li><strong>Використовуйте мінімальні базові образи:</strong> Alpine, Distroless, scratch</li>
          <li><strong>Скануйте образи на вразливості:</strong> Trivy, Snyk, Clair, Docker Scout</li>
          <li><strong>Підписуйте образи:</strong> Docker Content Trust, Sigstore/Cosign</li>
          <li><strong>Використовуйте приватний registry:</strong> з контролем доступу</li>
        </ul>

        <h4>Безпечний Dockerfile</h4>
        <pre>
# Multi-stage build для зменшення розміру та видалення build tools
FROM golang:1.21 AS builder
WORKDIR /app
COPY . .
RUN CGO_ENABLED=0 go build -o myapp

FROM alpine:3.18
# Створюємо non-root користувача
RUN addgroup -S appgroup && adduser -S appuser -G appgroup
USER appuser
COPY --from=builder /app/myapp /myapp
# Не використовуємо latest
# Вказуємо конкретні версії пакетів
ENTRYPOINT ["/myapp"]
        </pre>

        <ul>
          <li><strong>Multi-stage builds:</strong> фінальний образ без build tools</li>
          <li><strong>Non-root user:</strong> USER інструкція в Dockerfile</li>
          <li><strong>Мінімізуйте layers:</strong> об'єднуйте RUN команди</li>
          <li><strong>Не копіюйте секрети:</strong> використовуйте build secrets або runtime injection</li>
          <li><strong>.dockerignore:</strong> виключіть непотрібні файли</li>
        </ul>

        <h4>Runtime Security</h4>
        <pre>
# Запуск з обмеженнями
docker run \
  --read-only \
  --cap-drop=ALL \
  --cap-add=NET_BIND_SERVICE \
  --security-opt=no-new-privileges:true \
  --memory=512m \
  --cpus=1 \
  --user 1000:1000 \
  myimage
        </pre>

        <ul>
          <li><strong>Drop capabilities:</strong> --cap-drop=ALL, додавайте тільки потрібні</li>
          <li><strong>Read-only filesystem:</strong> --read-only</li>
          <li><strong>No new privileges:</strong> --security-opt=no-new-privileges</li>
          <li><strong>Resource limits:</strong> --memory, --cpus</li>
          <li><strong>Seccomp profiles:</strong> обмеження системних викликів</li>
          <li><strong>AppArmor/SELinux:</strong> mandatory access control</li>
        </ul>

        <h4>Управління секретами</h4>
        <ul>
          <li><strong>Docker Secrets:</strong> для Docker Swarm</li>
          <li><strong>Environment variables:</strong> тільки для некритичних налаштувань</li>
          <li><strong>External secret managers:</strong> HashiCorp Vault, AWS Secrets Manager</li>
          <li><strong>Kubernetes Secrets:</strong> з encryption at rest</li>
        </ul>
      </section>

      <section>
        <h2>4.3 Безпека Kubernetes</h2>

        <h3>Архітектура Kubernetes</h3>
        <p>Kubernetes (K8s) — це платформа оркестрації контейнерів, яка автоматизує розгортання, масштабування та управління контейнеризованими додатками. Розуміння архітектури критичне для розуміння безпеки.</p>

        <h4>Control Plane (Master)</h4>
        <ul>
          <li><strong>API Server:</strong> центральний компонент, через який проходять усі запити</li>
          <li><strong>etcd:</strong> розподілене сховище конфігурації кластера</li>
          <li><strong>Scheduler:</strong> розміщує pods на nodes</li>
          <li><strong>Controller Manager:</strong> керує контролерами (ReplicaSet, Deployment, etc.)</li>
        </ul>

        <h4>Worker Nodes</h4>
        <ul>
          <li><strong>Kubelet:</strong> агент, що запускає pods на node</li>
          <li><strong>Container Runtime:</strong> Docker, containerd, CRI-O</li>
          <li><strong>Kube-proxy:</strong> мережева маршрутизація</li>
        </ul>

        <!-- Diagram: Kubernetes Architecture -->
        <div class="diagram">
          <div class="diagram-title">Архітектура Kubernetes: Control Plane та Worker Nodes</div>
          <svg viewBox="0 0 700 320" xmlns="http://www.w3.org/2000/svg">
            <!-- Control Plane box -->
            <rect fill="#dbeafe" stroke="#3b82f6" stroke-width="2" x="20" y="30" width="280" height="200" rx="12"/>
            <text fill="#1d4ed8" x="160" y="55" text-anchor="middle" font-weight="600" font-size="14">Control Plane</text>

            <!-- API Server -->
            <rect fill="#3b82f6" x="100" y="70" width="120" height="40" rx="6"/>
            <text fill="white" x="160" y="95" text-anchor="middle" font-size="11">API Server</text>

            <!-- etcd -->
            <rect fill="#f59e0b" x="40" y="130" width="80" height="35" rx="6"/>
            <text fill="white" x="80" y="152" text-anchor="middle" font-size="10">etcd</text>

            <!-- Scheduler -->
            <rect fill="#22c55e" x="130" y="130" width="80" height="35" rx="6"/>
            <text fill="white" x="170" y="152" text-anchor="middle" font-size="10">Scheduler</text>

            <!-- Controller Manager -->
            <rect fill="#8b5cf6" x="220" y="130" width="70" height="35" rx="6"/>
            <text fill="white" x="255" y="147" text-anchor="middle" font-size="9">Controller</text>
            <text fill="white" x="255" y="158" text-anchor="middle" font-size="9">Manager</text>

            <!-- Cloud Controller -->
            <rect fill="#ec4899" x="80" y="180" width="100" height="30" rx="6"/>
            <text fill="white" x="130" y="200" text-anchor="middle" font-size="9">Cloud Controller</text>

            <!-- Lines connecting to API Server -->
            <line stroke="var(--text-secondary)" stroke-width="1" x1="80" y1="130" x2="120" y2="110"/>
            <line stroke="var(--text-secondary)" stroke-width="1" x1="170" y1="130" x2="170" y2="110"/>
            <line stroke="var(--text-secondary)" stroke-width="1" x1="240" y1="130" x2="200" y2="110"/>
            <line stroke="var(--text-secondary)" stroke-width="1" x1="130" y1="180" x2="150" y2="110"/>

            <!-- Worker Nodes -->
            <rect fill="#dcfce7" stroke="#22c55e" stroke-width="2" x="400" y="30" width="280" height="120" rx="12"/>
            <text fill="#166534" x="540" y="50" text-anchor="middle" font-weight="600" font-size="12">Worker Node 1</text>

            <!-- Kubelet -->
            <rect fill="#22c55e" x="420" y="65" width="70" height="35" rx="6"/>
            <text fill="white" x="455" y="87" text-anchor="middle" font-size="10">Kubelet</text>

            <!-- Kube-proxy -->
            <rect fill="#0ea5e9" x="500" y="65" width="70" height="35" rx="6"/>
            <text fill="white" x="535" y="87" text-anchor="middle" font-size="10">Kube-proxy</text>

            <!-- Container Runtime -->
            <rect fill="#64748b" x="580" y="65" width="80" height="35" rx="6"/>
            <text fill="white" x="620" y="82" text-anchor="middle" font-size="9">Container</text>
            <text fill="white" x="620" y="93" text-anchor="middle" font-size="9">Runtime</text>

            <!-- Pods -->
            <g transform="translate(420, 108)">
              <rect fill="#bbf7d0" stroke="#22c55e" x="0" y="0" width="35" height="30" rx="4"/>
              <text fill="#166534" x="17" y="20" text-anchor="middle" font-size="9">Pod</text>
            </g>
            <g transform="translate(460, 108)">
              <rect fill="#bbf7d0" stroke="#22c55e" x="0" y="0" width="35" height="30" rx="4"/>
              <text fill="#166534" x="17" y="20" text-anchor="middle" font-size="9">Pod</text>
            </g>
            <g transform="translate(500, 108)">
              <rect fill="#bbf7d0" stroke="#22c55e" x="0" y="0" width="35" height="30" rx="4"/>
              <text fill="#166534" x="17" y="20" text-anchor="middle" font-size="9">Pod</text>
            </g>

            <!-- Worker Node 2 -->
            <rect fill="#fef3c7" stroke="#f59e0b" stroke-width="2" x="400" y="170" width="280" height="60" rx="12"/>
            <text fill="#b45309" x="540" y="195" text-anchor="middle" font-size="11">Worker Node 2 (Kubelet, Kube-proxy, Pods...)</text>

            <!-- Worker Node 3 -->
            <rect fill="#fce7f3" stroke="#ec4899" stroke-width="2" x="400" y="240" width="280" height="60" rx="12"/>
            <text fill="#be185d" x="540" y="265" text-anchor="middle" font-size="11">Worker Node N ...</text>

            <!-- Connection arrows -->
            <line stroke="var(--accent)" stroke-width="2" x1="300" y1="90" x2="400" y2="90"/>
            <line stroke="var(--accent)" stroke-width="2" x1="300" y1="90" x2="400" y2="200"/>
            <line stroke="var(--accent)" stroke-width="2" x1="300" y1="90" x2="400" y2="270"/>
            <text fill="var(--accent)" x="350" y="80" text-anchor="middle" font-size="9">kubectl</text>
          </svg>
          <div class="diagram-caption">Рис. 4.2. Архітектура Kubernetes кластера: Control Plane керує, Worker Nodes виконують</div>
        </div>

        <h3>Загрози безпеці Kubernetes</h3>

        <h4>1. Exposed API Server</h4>
        <p>API Server — головна ціль атакуючих. Якщо він доступний без автентифікації:</p>
        <ul>
          <li>Повний контроль над кластером</li>
          <li>Можливість запускати довільні контейнери</li>
          <li>Доступ до секретів та конфігурації</li>
        </ul>

        <p><strong>Приклад:</strong> Tesla (2018) — криптомайнери в Kubernetes через відкритий dashboard.</p>

        <h4>2. Compromised etcd</h4>
        <p>etcd зберігає всю конфігурацію кластера, включаючи Secrets:</p>
        <ul>
          <li>Secrets зберігаються в base64 (не шифровані за замовчуванням)</li>
          <li>Доступ до etcd = доступ до всіх секретів</li>
        </ul>

        <h4>3. Pod Security Issues</h4>
        <ul>
          <li>Privileged pods</li>
          <li>Host namespace sharing (hostPID, hostNetwork)</li>
          <li>Sensitive volume mounts</li>
          <li>Running as root</li>
        </ul>

        <h4>4. RBAC Misconfiguration</h4>
        <ul>
          <li>Занадто широкі права (cluster-admin для всіх)</li>
          <li>Wildcard permissions (*)</li>
          <li>Default service accounts з надмірними правами</li>
        </ul>

        <h3>Механізми безпеки Kubernetes</h3>

        <h4>RBAC (Role-Based Access Control)</h4>
        <p>RBAC контролює, хто може виконувати які дії в кластері:</p>

        <pre>
# Role — права в межах namespace
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: production
  name: pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]

---
# RoleBinding — прив'язка Role до користувача
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: read-pods
  namespace: production
subjects:
- kind: User
  name: developer
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
        </pre>

        <p><strong>Best Practices RBAC:</strong></p>
        <ul>
          <li>Principle of least privilege</li>
          <li>Namespace isolation</li>
          <li>Уникайте ClusterRole з широкими правами</li>
          <li>Регулярний аудит прав</li>
        </ul>

        <h4>Network Policies</h4>
        <p>Network Policies контролюють мережевий трафік між pods:</p>

        <pre>
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-ingress
  namespace: production
spec:
  podSelector: {}
  policyTypes:
  - Ingress

---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend
    ports:
    - protocol: TCP
      port: 8080
        </pre>

        <p><strong>Важливо:</strong> Network Policies потребують CNI plugin, що їх підтримує (Calico, Cilium, Weave Net).</p>

        <h4>Pod Security Standards (PSS)</h4>
        <p>Pod Security Standards визначають три рівні безпеки:</p>

        <ul>
          <li><strong>Privileged:</strong> необмежений (для system workloads)</li>
          <li><strong>Baseline:</strong> мінімальні обмеження (запобігає очевидним ескалаціям)</li>
          <li><strong>Restricted:</strong> суворі обмеження (найкращі практики)</li>
        </ul>

        <pre>
# Застосування через namespace labels
apiVersion: v1
kind: Namespace
metadata:
  name: production
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
        </pre>

        <h4>Secrets Management</h4>
        <pre>
# Увімкнення encryption at rest для etcd
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
      - secrets
    providers:
      - aescbc:
          keys:
            - name: key1
              secret: <base64-encoded-key>
      - identity: {}
        </pre>

        <p><strong>Кращі практики:</strong></p>
        <ul>
          <li>Encryption at rest для etcd</li>
          <li>External secret management (Vault, Sealed Secrets, External Secrets Operator)</li>
          <li>Не зберігайте секрети в Git</li>
          <li>Ротація секретів</li>
        </ul>

        <h4>Admission Controllers</h4>
        <p>Admission Controllers перехоплюють запити до API Server і можуть валідувати або модифікувати їх:</p>
        <ul>
          <li><strong>PodSecurity:</strong> застосування Pod Security Standards</li>
          <li><strong>OPA Gatekeeper:</strong> policy-as-code</li>
          <li><strong>Kyverno:</strong> Kubernetes-native policies</li>
        </ul>

        <h3>Kubernetes Security Checklist</h3>
        <ul>
          <li>API Server доступний тільки з приватної мережі</li>
          <li>RBAC увімкнено, мінімальні права</li>
          <li>Network Policies для всіх namespaces</li>
          <li>Pod Security Standards: Restricted для production</li>
          <li>etcd зашифрований та ізольований</li>
          <li>Secrets зашифровані at rest</li>
          <li>Audit logging увімкнено</li>
          <li>Container images скануються</li>
          <li>Service accounts з мінімальними правами</li>
        </ul>

        <!-- Diagram: Kubernetes Security Layers -->
        <div class="diagram">
          <div class="diagram-title">Рівні безпеки Kubernetes: Defense in Depth</div>
          <svg viewBox="0 0 700 300" xmlns="http://www.w3.org/2000/svg">
            <!-- Outer layer: Cluster -->
            <rect fill="#fee2e2" stroke="#ef4444" stroke-width="2" x="30" y="20" width="640" height="260" rx="16"/>
            <text fill="#dc2626" x="350" y="45" text-anchor="middle" font-weight="600" font-size="12">Cluster Security (API Server, etcd, Network)</text>

            <!-- Second layer: Namespace -->
            <rect fill="#fef3c7" stroke="#f59e0b" stroke-width="2" x="60" y="60" width="580" height="200" rx="12"/>
            <text fill="#b45309" x="350" y="82" text-anchor="middle" font-weight="600" font-size="11">Namespace Isolation (RBAC, Network Policies, Resource Quotas)</text>

            <!-- Third layer: Pod -->
            <rect fill="#dbeafe" stroke="#3b82f6" stroke-width="2" x="90" y="100" width="520" height="140" rx="10"/>
            <text fill="#1d4ed8" x="350" y="120" text-anchor="middle" font-weight="600" font-size="11">Pod Security (PSS, Service Accounts, Security Context)</text>

            <!-- Inner layer: Container -->
            <g transform="translate(120, 135)">
              <rect fill="#dcfce7" stroke="#22c55e" stroke-width="2" x="0" y="0" width="140" height="85" rx="8"/>
              <text fill="#166534" x="70" y="20" text-anchor="middle" font-weight="600" font-size="10">Container</text>
              <text fill="#166534" x="70" y="38" text-anchor="middle" font-size="8">Read-only rootfs</text>
              <text fill="#166534" x="70" y="50" text-anchor="middle" font-size="8">Non-root user</text>
              <text fill="#166534" x="70" y="62" text-anchor="middle" font-size="8">Dropped capabilities</text>
              <text fill="#166534" x="70" y="74" text-anchor="middle" font-size="8">Seccomp profile</text>
            </g>

            <g transform="translate(280, 135)">
              <rect fill="#dcfce7" stroke="#22c55e" stroke-width="2" x="0" y="0" width="140" height="85" rx="8"/>
              <text fill="#166534" x="70" y="20" text-anchor="middle" font-weight="600" font-size="10">Container</text>
              <text fill="#166534" x="70" y="38" text-anchor="middle" font-size="8">Image scanning</text>
              <text fill="#166534" x="70" y="50" text-anchor="middle" font-size="8">Signed images</text>
              <text fill="#166534" x="70" y="62" text-anchor="middle" font-size="8">Minimal base image</text>
              <text fill="#166534" x="70" y="74" text-anchor="middle" font-size="8">No secrets in image</text>
            </g>

            <g transform="translate(440, 135)">
              <rect fill="#dcfce7" stroke="#22c55e" stroke-width="2" x="0" y="0" width="140" height="85" rx="8"/>
              <text fill="#166534" x="70" y="20" text-anchor="middle" font-weight="600" font-size="10">Container</text>
              <text fill="#166534" x="70" y="38" text-anchor="middle" font-size="8">Resource limits</text>
              <text fill="#166534" x="70" y="50" text-anchor="middle" font-size="8">Liveness probes</text>
              <text fill="#166534" x="70" y="62" text-anchor="middle" font-size="8">Network isolation</text>
              <text fill="#166534" x="70" y="74" text-anchor="middle" font-size="8">Audit logging</text>
            </g>
          </svg>
          <div class="diagram-caption">Рис. 4.3. Defense in Depth у Kubernetes: кожен рівень додає захист</div>
        </div>

        <h3>Реальні інциденти безпеки Kubernetes</h3>

        <h4>Tesla Cryptojacking (2018)</h4>
        <p>Атакуючі знайшли незахищену Kubernetes dashboard Tesla без автентифікації:</p>
        <ul>
          <li><strong>Вектор атаки:</strong> Публічно доступний Kubernetes Dashboard без пароля</li>
          <li><strong>Експлуатація:</strong> Запуск pods для криптомайнінгу</li>
          <li><strong>Наслідки:</strong> Використання AWS ресурсів Tesla для майнінгу</li>
          <li><strong>Урок:</strong> Ніколи не виставляти dashboard без автентифікації</li>
        </ul>

        <h4>Shopify Bug Bounty (2020)</h4>
        <p>Дослідник знайшов спосіб отримати доступ до Google Cloud метаданих через Kubernetes:</p>
        <ul>
          <li><strong>Вектор:</strong> SSRF через pod до metadata service</li>
          <li><strong>Отримані дані:</strong> Service account credentials</li>
          <li><strong>Вплив:</strong> Потенційний доступ до GCP ресурсів</li>
          <li><strong>Захист:</strong> Workload Identity, metadata concealment</li>
        </ul>

        <h4>Приклад безпечного Pod manifest</h4>
        <pre>
apiVersion: v1
kind: Pod
metadata:
  name: secure-pod
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 10000
    runAsGroup: 10000
    fsGroup: 10000
    seccompProfile:
      type: RuntimeDefault
  containers:
  - name: app
    image: myregistry/myapp:v1.2.3@sha256:abc123...
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
          - ALL
    resources:
      limits:
        memory: "128Mi"
        cpu: "500m"
      requests:
        memory: "64Mi"
        cpu: "250m"
    livenessProbe:
      httpGet:
        path: /health
        port: 8080
      initialDelaySeconds: 3
      periodSeconds: 10
  automountServiceAccountToken: false
        </pre>
      </section>

      <section>
        <h2>4.4 CWPP та захист Runtime</h2>

        <h3>Що таке CWPP?</h3>
        <p><strong>Cloud Workload Protection Platform (CWPP)</strong> — це категорія security-рішень, визначена Gartner, яка фокусується на захисті серверних workloads у хмарних, гібридних та on-premises середовищах.</p>

        <p>CWPP еволюціонувала з традиційних endpoint protection рішень, адаптуючись до специфіки хмарних та контейнерних середовищ.</p>

        <h3>Ключові можливості CWPP</h3>

        <h4>1. Vulnerability Management</h4>
        <ul>
          <li>Сканування образів контейнерів на вразливості</li>
          <li>Сканування VM та хостів</li>
          <li>Пріоритизація на основі exploitability та контексту</li>
          <li>Інтеграція з CI/CD для shift-left</li>
        </ul>

        <h4>2. Runtime Protection</h4>
        <ul>
          <li>Виявлення аномальної поведінки процесів</li>
          <li>Захист від malware та cryptominers</li>
          <li>File integrity monitoring</li>
          <li>Network anomaly detection</li>
        </ul>

        <h4>3. Compliance & Configuration</h4>
        <ul>
          <li>Перевірка конфігурації на відповідність benchmarks (CIS)</li>
          <li>Compliance reporting (PCI DSS, HIPAA, SOC 2)</li>
          <li>Infrastructure as Code scanning</li>
        </ul>

        <h4>4. Network Security</h4>
        <ul>
          <li>Візуалізація мережевих потоків</li>
          <li>Мікросегментація</li>
          <li>Firewall policies</li>
        </ul>

        <h3>Runtime Security</h3>
        <p>Runtime security фокусується на захисті workloads під час їх виконання. Це критично, оскільки багато атак відбуваються саме в runtime, коли системи вже розгорнуті.</p>

        <h4>Підходи до Runtime Security</h4>

        <p><strong>1. System Call Monitoring</strong></p>
        <p>Моніторинг системних викликів дозволяє виявити підозрілу активність:</p>
        <ul>
          <li>Несподівані process executions (reverse shell)</li>
          <li>File access anomalies</li>
          <li>Network connections</li>
        </ul>

        <p><strong>Інструменти:</strong></p>
        <ul>
          <li><strong>Falco:</strong> Open-source runtime security від Sysdig, CNCF project</li>
          <li><strong>Tetragon:</strong> eBPF-based security observability від Cilium</li>
          <li><strong>Tracee:</strong> eBPF-based runtime security від Aqua</li>
        </ul>

        <p><strong>Приклад Falco rule:</strong></p>
        <pre>
- rule: Terminal shell in container
  desc: Detect a shell opened in a container
  condition: >
    spawned_process and container and
    shell_procs and proc.tty != 0
  output: >
    Shell opened in container
    (user=%user.name container=%container.name shell=%proc.name)
  priority: WARNING
  tags: [container, shell]
        </pre>

        <p><strong>2. eBPF-based Security</strong></p>
        <p>eBPF (extended Berkeley Packet Filter) — це технологія, яка дозволяє запускати sandboxed програми в ядрі Linux без модифікації ядра:</p>
        <ul>
          <li>Низький overhead</li>
          <li>Глибока видимість (kernel-level)</li>
          <li>Можливість enforcement</li>
        </ul>

        <p><strong>3. Image Signing & Verification</strong></p>
        <p>Перевірка, що запускаються тільки довірені образи:</p>
        <ul>
          <li><strong>Sigstore/Cosign:</strong> підписування та верифікація образів</li>
          <li><strong>Kubernetes admission controller:</strong> блокування непідписаних образів</li>
          <li><strong>Binary Authorization (GCP):</strong> native image verification</li>
        </ul>

        <h3>Популярні CWPP рішення</h3>

        <h4>Commercial</h4>
        <ul>
          <li><strong>Palo Alto Prisma Cloud:</strong> повнофункціональна CNAPP платформа</li>
          <li><strong>CrowdStrike Falcon:</strong> EDR + CWPP</li>
          <li><strong>Aqua Security:</strong> фокус на контейнери та Kubernetes</li>
          <li><strong>Sysdig:</strong> monitoring + security</li>
          <li><strong>Wiz:</strong> agentless CNAPP</li>
        </ul>

        <h4>Open Source</h4>
        <ul>
          <li><strong>Falco:</strong> runtime threat detection</li>
          <li><strong>Trivy:</strong> vulnerability scanning</li>
          <li><strong>Checkov:</strong> IaC scanning</li>
          <li><strong>Kube-bench:</strong> CIS Kubernetes benchmarks</li>
          <li><strong>Kubescape:</strong> Kubernetes security scanning</li>
        </ul>

        <h3>CWPP у хмарних провайдерах</h3>
        <p>Кожен великий хмарний провайдер пропонує native CWPP-можливості. Перевага native рішень — глибока інтеграція. Недолік — vendor lock-in та обмежена multi-cloud підтримка.</p>

        <h4>AWS</h4>
        <p>AWS пропонує набір окремих сервісів, які разом формують CWPP-стек:</p>
        <ul>
          <li><strong>Amazon Inspector:</strong> автоматичне сканування EC2, Lambda та container images на вразливості. Інтегрується з ECR — сканує образи автоматично при push. Пріоритизує вразливості на основі CVSS + network reachability.</li>
          <li><strong>Amazon GuardDuty:</strong> threat detection на базі ML. Для EKS аналізує Kubernetes audit logs та виявляє: підозрілі API-виклики, privilege escalation спроби, cryptomining, DNS-based exfiltration.</li>
          <li><strong>AWS Security Hub:</strong> централізований dashboard, що агрегує findings з Inspector, GuardDuty, Macie, IAM Access Analyzer. Підтримує автоматичні remediation actions через EventBridge.</li>
          <li><strong>Amazon ECR Image Scanning:</strong> базове та enhanced (powered by Inspector) сканування container images.</li>
        </ul>

        <h4>Azure</h4>
        <p>Microsoft пропонує найбільш інтегроване CWPP-рішення серед трьох провайдерів:</p>
        <ul>
          <li><strong>Microsoft Defender for Cloud:</strong> CSPM + CWPP в одному рішенні. Покриває VM, контейнери, serverless, бази даних. Також підтримує multi-cloud (AWS, GCP) через Arc.</li>
          <li><strong>Defender for Containers:</strong> спеціалізований модуль для AKS та EKS: vulnerability scanning образів, runtime threat detection, Kubernetes security posture management, admission control recommendations.</li>
          <li><strong>Defender for Servers:</strong> EDR для VM на базі Microsoft Defender for Endpoint. Включає vulnerability assessment, file integrity monitoring, adaptive application control.</li>
        </ul>

        <h4>GCP</h4>
        <p>GCP робить акцент на security-by-default та інтеграції з Kubernetes (Google створив Kubernetes):</p>
        <ul>
          <li><strong>Security Command Center (SCC):</strong> централізований security management. Premium tier включає Container Threat Detection, Web Security Scanner, Event Threat Detection.</li>
          <li><strong>Container Threat Detection:</strong> runtime protection, що виявляє підозрілі binary executions, reverse shells, data exfiltration з GKE pods.</li>
          <li><strong>Binary Authorization:</strong> admission control, що дозволяє запуск лише підписаних образів. Інтегрується з Artifact Registry та Cloud Build для end-to-end supply chain security.</li>
          <li><strong>Artifact Analysis:</strong> vulnerability scanning для container images в Artifact Registry. Автоматичне сканування при push.</li>
        </ul>

        <h3>Інтеграція в DevSecOps Pipeline</h3>
        <pre>
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│    Code     │ ──► │    Build    │ ──► │   Deploy    │ ──► │   Runtime   │
└─────────────┘     └─────────────┘     └─────────────┘     └─────────────┘
      │                   │                   │                   │
      ▼                   ▼                   ▼                   ▼
  SAST/SCA          Image Scan         Admission          Runtime
  (Snyk,            (Trivy,            Control            Protection
  Semgrep)          Clair)             (OPA, Kyverno)     (Falco)
        </pre>

        <ul>
          <li><strong>Shift Left:</strong> виявляйте проблеми якомога раніше</li>
          <li><strong>Automate:</strong> інтегруйте security checks у CI/CD</li>
          <li><strong>Fail builds:</strong> блокуйте deployment при критичних проблемах</li>
          <li><strong>Monitor continuously:</strong> runtime захист як останній рубіж</li>
        </ul>
      </section>

      <section>
        <h2>4.5 Supply Chain Security для контейнерів</h2>

        <p>Supply chain security — одна з найгарячіших тем у хмарній безпеці. Ваш контейнерний додаток складається з десятків шарів: базовий образ ОС, системні бібліотеки, мовний runtime, фреймворки, ваш код. Компрометація будь-якого шару означає компрометацію всього додатку.</p>

        <h3>Чому supply chain security критичний?</h3>

        <p>Кілька інцидентів змусили індустрію переглянути підхід до supply chain:</p>
        <ul>
          <li><strong>SolarWinds (2020):</strong> компрометоване оновлення торкнулося 18,000+ організацій, включаючи US Treasury та Department of Homeland Security.</li>
          <li><strong>Log4Shell (2021):</strong> CVE-2021-44228 у Log4j — бібліотеці, вбудованій у мільйони Java-додатків та контейнерів. Організації тижнями не могли знайти всі місця, де використовувався Log4j.</li>
          <li><strong>Codecov (2021):</strong> атакуючі модифікували bash uploader, отримавши доступ до CI/CD secrets тисяч компаній.</li>
          <li><strong>Malicious Docker Hub images:</strong> регулярно виявляються образи з вбудованими cryptominers або backdoors, що маскуються під легітимні.</li>
        </ul>

        <h3>SBOM — Software Bill of Materials</h3>

        <p><strong>SBOM</strong> — це повний перелік компонентів, з яких складається ваш програмний продукт. Думайте про це як про список інгредієнтів на продуктовому пакуванні, але для програмного забезпечення.</p>

        <p><strong>Навіщо потрібен SBOM:</strong></p>
        <ul>
          <li><strong>Vulnerability response:</strong> коли з'являється нова CVE (як Log4Shell), SBOM дозволяє миттєво знайти всі affected компоненти, замість ручного пошуку</li>
          <li><strong>License compliance:</strong> знати, які open-source ліцензії використовуються</li>
          <li><strong>Regulatory requirements:</strong> US Executive Order 14028 (2021) вимагає SBOM для постачальників федерального уряду</li>
        </ul>

        <p><strong>Формати SBOM:</strong></p>
        <ul>
          <li><strong>SPDX (Software Package Data Exchange):</strong> стандарт Linux Foundation, ISO/IEC 5962:2021</li>
          <li><strong>CycloneDX:</strong> стандарт OWASP, фокус на безпеці</li>
        </ul>

        <p><strong>Інструменти генерації SBOM:</strong></p>
        <pre>
# Генерація SBOM для Docker образу за допомогою Syft
$ syft myimage:latest -o spdx-json > sbom.json

# Генерація SBOM за допомогою Trivy
$ trivy image --format spdx-json myimage:latest > sbom.json

# Перевірка SBOM на вразливості за допомогою Grype
$ grype sbom:sbom.json
        </pre>

        <h3>SLSA — Supply-chain Levels for Software Artifacts</h3>

        <p><strong>SLSA</strong> (вимовляється "salsa") — це фреймворк від Google для забезпечення цілісності supply chain. Він визначає чотири рівні зрілості:</p>

        <table>
          <tr>
            <th>Рівень</th>
            <th>Вимоги</th>
            <th>Захищає від</th>
          </tr>
          <tr>
            <td><strong>SLSA 1</strong></td>
            <td>Документований build process, автоматична генерація provenance</td>
            <td>Незадокументовані зміни</td>
          </tr>
          <tr>
            <td><strong>SLSA 2</strong></td>
            <td>Version control, hosted build service, автентифікований provenance</td>
            <td>Модифікація після build</td>
          </tr>
          <tr>
            <td><strong>SLSA 3</strong></td>
            <td>Hardened build platform, non-falsifiable provenance</td>
            <td>Компрометація build process</td>
          </tr>
          <tr>
            <td><strong>SLSA 4</strong></td>
            <td>Two-person review, hermetic builds, reproducible</td>
            <td>Insider threats, sophisticated attacks</td>
          </tr>
        </table>

        <p><strong>Provenance</strong> — ключове поняття SLSA. Це криптографічно підписаний документ, який відповідає на три питання: що було збудовано? з якого вихідного коду? на якій build-платформі?</p>

        <h3>Sigstore — підпис та верифікація артефактів</h3>

        <p><strong>Sigstore</strong> — це open-source проєкт (Linux Foundation) для підписування, верифікації та захисту software supply chain. Він складається з трьох компонентів:</p>
        <ul>
          <li><strong>Cosign:</strong> підписування та верифікація container images та інших OCI-артефактів</li>
          <li><strong>Fulcio:</strong> certificate authority для keyless signing (використовує OIDC identity замість довготривалих ключів)</li>
          <li><strong>Rekor:</strong> transparency log — публічний, immutable реєстр підписів</li>
        </ul>

        <p><strong>Приклад підпису та верифікації образу:</strong></p>
        <pre>
# Підпис образу (keyless — використовує OIDC identity)
$ cosign sign myregistry.io/myimage:v1.0

# Верифікація підпису
$ cosign verify myregistry.io/myimage:v1.0

# Інтеграція з Kubernetes — admission policy
# Kyverno policy для перевірки підпису
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: verify-image-signature
spec:
  validationFailureAction: Enforce
  rules:
  - name: verify-cosign-signature
    match:
      any:
      - resources:
          kinds:
          - Pod
    verifyImages:
    - imageReferences:
      - "myregistry.io/*"
      attestors:
      - entries:
        - keyless:
            issuer: "https://accounts.google.com"
            subject: "builder@mycompany.iam.gserviceaccount.com"
        </pre>

        <h3>Повний pipeline supply chain security</h3>

        <p>Комплексний підхід до supply chain security включає захист на кожному етапі:</p>
        <ol>
          <li><strong>Source:</strong> підписані коміти (git commit signing), branch protection rules, code review</li>
          <li><strong>Dependencies:</strong> SCA (Software Composition Analysis) — Snyk, Dependabot, Renovate. Lock-файли для фіксації версій.</li>
          <li><strong>Build:</strong> hardened CI/CD (isolated runners, no secrets in logs), SLSA provenance generation</li>
          <li><strong>Package:</strong> сканування образів (Trivy, Grype), SBOM генерація, підпис (Cosign)</li>
          <li><strong>Deploy:</strong> admission control (Kyverno, OPA Gatekeeper) — верифікація підпису та policy compliance</li>
          <li><strong>Runtime:</strong> continuous monitoring (Falco), drift detection, image re-scanning</li>
        </ol>
      </section>

      <section>
        <h2>Висновки</h2>
        <p>Віртуалізація та контейнеризація — це основа сучасних хмарних обчислень. Але ці технології приносять специфічні безпекові виклики, які потребують уваги.</p>

        <h3>Ключові тези</h3>
        <ul>
          <li><strong>Гіпервізор — критичний компонент:</strong> його компрометація впливає на всі VM. VM escape — рідкісна, але катастрофічна атака.</li>
          <li><strong>Контейнери не є VM:</strong> спільне ядро означає слабшу ізоляцію. Privileged container = повний контроль над хостом.</li>
          <li><strong>Misconfiguration — головний ворог:</strong> більшість інцидентів через неправильні налаштування, а не zero-day вразливості.</li>
          <li><strong>Defense in depth:</strong> кілька рівнів захисту — image scanning + admission control + runtime monitoring + network policies.</li>
          <li><strong>Shift left:</strong> виявляйте проблеми на етапі розробки, а не в production. SBOM + SLSA для supply chain.</li>
          <li><strong>Supply chain — новий вектор:</strong> ваш додаток настільки безпечний, наскільки безпечний найслабший компонент у його ланцюзі залежностей.</li>
        </ul>

        <h3>Практичні рекомендації</h3>
        <ol>
          <li>Використовуйте мінімальні базові образи</li>
          <li>Скануйте образи на вразливості в CI/CD</li>
          <li>Запускайте контейнери від non-root користувача</li>
          <li>Застосовуйте Network Policies в Kubernetes</li>
          <li>Увімкніть Pod Security Standards: Restricted</li>
          <li>Шифруйте Secrets at rest</li>
          <li>Впровадьте runtime monitoring (Falco)</li>
        </ol>
      </section>

      <section>
        <h2>Питання для самоперевірки</h2>
        <ol>
          <li>Чим відрізняються гіпервізори типу 1 та типу 2?</li>
          <li>Що таке VM escape і як від нього захиститися?</li>
          <li>Які механізми ядра Linux використовує Docker для ізоляції?</li>
          <li>Чому не варто запускати контейнери в privileged mode?</li>
          <li>Як працює RBAC в Kubernetes? Чим відрізняються Role та ClusterRole?</li>
          <li>Що таке Pod Security Standards і які рівні вони визначають?</li>
          <li>Яку роль відіграє CWPP у захисті хмарних workloads?</li>
          <li>Як eBPF використовується для runtime security?</li>
          <li>Що таке SBOM і чому він став обов'язковим для постачальників уряду США?</li>
          <li>Опишіть чотири рівні SLSA. Який мінімальний рівень ви б рекомендували для production-систем?</li>
          <li>Як Sigstore/Cosign забезпечує цілісність container images? Чим keyless signing відрізняється від традиційного?</li>
          <li>Порівняйте native CWPP-рішення AWS, Azure та GCP. Які переваги та недоліки native vs third-party рішень?</li>
        </ol>
      </section>

      <section>
        <h3>Практичне завдання</h3>
        <p>Ваша команда розробляє мікросервісний додаток на Kubernetes, що складається з 4 сервісів: frontend (React), API gateway (Node.js), backend (Python), database (PostgreSQL).</p>

        <p><strong>Завдання:</strong></p>
        <ol>
          <li><strong>Dockerfile hardening:</strong> Напишіть безпечний Dockerfile для Python backend-сервісу. Використайте multi-stage build, non-root user, мінімальний базовий образ, health check. Поясніть кожне рішення.</li>
          <li><strong>Kubernetes security:</strong> Створіть набір Kubernetes manifests:
            <ul>
              <li>NetworkPolicy — frontend може звертатися лише до API gateway; API gateway — лише до backend; backend — лише до database</li>
              <li>Pod Security Context для backend — restricted profile</li>
              <li>RBAC — роль "developer" може читати pods та logs, але не може exec в контейнери</li>
            </ul>
          </li>
          <li><strong>CI/CD security pipeline:</strong> Спроєктуйте pipeline для GitHub Actions, що включає: SAST (Semgrep), image scanning (Trivy), SBOM generation (Syft), image signing (Cosign), deployment з admission control (Kyverno).</li>
          <li><strong>Incident response:</strong> Falco виявив alert "shell opened in container" для backend pod о 3:00 AM. Опишіть покрокову процедуру реагування.</li>
        </ol>
      </section>

      <section>
        <h3>Рекомендовані ресурси для подальшого вивчення</h3>
        <ul>
          <li><a href="https://kubernetes.io/docs/concepts/security/" target="_blank" rel="noopener">Kubernetes Security Documentation</a> — офіційна документація з безпеки Kubernetes</li>
          <li><a href="https://docs.docker.com/engine/security/" target="_blank" rel="noopener">Docker Security</a> — офіційний гайд з безпеки Docker</li>
          <li><a href="https://www.cisecurity.org/benchmark/kubernetes" target="_blank" rel="noopener">CIS Kubernetes Benchmark</a> — золотий стандарт конфігурації безпеки K8s</li>
          <li><a href="https://falco.org/docs/" target="_blank" rel="noopener">Falco Documentation</a> — runtime threat detection для контейнерів</li>
          <li><a href="https://slsa.dev/" target="_blank" rel="noopener">SLSA Framework</a> — Supply-chain Levels for Software Artifacts</li>
          <li><a href="https://www.sigstore.dev/" target="_blank" rel="noopener">Sigstore</a> — підписування та верифікація software artifacts</li>
          <li><a href="https://aquasecurity.github.io/trivy/" target="_blank" rel="noopener">Trivy</a> — vulnerability scanner для containers, IaC, SBOM</li>
          <li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html" target="_blank" rel="noopener">OWASP Docker Security Cheat Sheet</a> — практичний чеклист безпеки Docker</li>
          <li><a href="https://sysdig.com/learn-cloud-native/kubernetes-security/" target="_blank" rel="noopener">Sysdig Kubernetes Security Guide</a> — детальний гайд з безпеки K8s від Sysdig</li>
        </ul>
      </section>

      <section>
        <h3>Глосарій ключових термінів</h3>
        <ul>
          <li><strong>Гіпервізор (Hypervisor)</strong> — програмне забезпечення для управління віртуальними машинами. Type 1 (bare-metal): KVM, ESXi, Xen. Type 2 (hosted): VirtualBox, VMware Workstation.</li>
          <li><strong>VM Escape</strong> — атака, при якій зловмисник виходить з віртуальної машини на рівень гіпервізора або хост-системи</li>
          <li><strong>Namespace</strong> — механізм ізоляції ядра Linux, що забезпечує ізольований вигляд системних ресурсів для процесів (PID, network, mount, user)</li>
          <li><strong>Cgroup</strong> — Control Group, механізм ядра Linux для обмеження та обліку ресурсів (CPU, RAM, I/O) для групи процесів</li>
          <li><strong>Container Escape</strong> — "втеча" з контейнера на хост-систему через вразливість у runtime (runc, containerd) або неправильну конфігурацію</li>
          <li><strong>Distroless</strong> — мінімальні container images від Google, що містять лише додаток та його runtime залежності (без shell, package manager)</li>
          <li><strong>RBAC</strong> — Role-Based Access Control, модель контролю доступу в Kubernetes на основі ролей</li>
          <li><strong>Pod Security Standards</strong> — три рівні обмежень Kubernetes: Privileged (без обмежень), Baseline (мінімальні), Restricted (максимальні)</li>
          <li><strong>NetworkPolicy</strong> — ресурс Kubernetes для контролю мережевого трафіку між pods (мікросегментація)</li>
          <li><strong>CWPP</strong> — Cloud Workload Protection Platform, категорія рішень для захисту серверних workloads у хмарі</li>
          <li><strong>eBPF</strong> — extended Berkeley Packet Filter, технологія для запуску sandboxed-програм у ядрі Linux без модифікації ядра</li>
          <li><strong>Falco</strong> — open-source runtime threat detection для контейнерів та Kubernetes (CNCF project)</li>
          <li><strong>SBOM</strong> — Software Bill of Materials, повний перелік компонентів програмного продукту</li>
          <li><strong>SLSA</strong> — Supply-chain Levels for Software Artifacts, фреймворк від Google для цілісності supply chain (4 рівні)</li>
          <li><strong>Sigstore</strong> — open-source інфраструктура для підписування та верифікації software artifacts (Cosign, Fulcio, Rekor)</li>
          <li><strong>OCI</strong> — Open Container Initiative, стандарт для container images та runtimes</li>
          <li><strong>Admission Controller</strong> — компонент Kubernetes, що перехоплює запити до API server та може дозволити, модифікувати або заблокувати їх</li>
          <li><strong>Service Mesh</strong> — інфраструктурний рівень для service-to-service комунікації з mTLS, observability та traffic management (Istio, Linkerd)</li>
        </ul>
      </section>

    </article>

    <footer id="footer"></footer>
  </main>

  <script src="../../js/main.js"></script>

</body>
</html>
