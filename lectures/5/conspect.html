<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Конспект лекції 5: Безпека безсерверних обчислень (Serverless Security).">
  <meta name="author" content="Кафедра ТЕІБ, Ужгородський національний університет">
  <meta name="theme-color" content="#0ea5e9">
  <title>Конспект лекції 5 — Безпека хмарних технологій</title>
  <link rel="icon" type="image/svg+xml" href="../../img/favicon.svg">
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../css/style.css">
  <link rel="stylesheet" href="../../css/print.css" media="print">
  <script>
    if (localStorage.getItem('theme') === 'dark') {
      document.documentElement.classList.add('dark');
    }
  </script>
</head>
<body>

  <aside>
    <div class="logo">
      <div class="logo-icon">
        <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/>
          <path d="M12 13v-1a2 2 0 0 1 2-2h0a2 2 0 0 1 2 2v1"/>
          <rect x="10" y="13" width="8" height="5" rx="1"/>
        </svg>
      </div>
      <div class="logo-text">
        Безпека<br>хмарних технологій
        <span>онлайн-курс</span>
      </div>
    </div>

    <nav>
      <a href="../../index.html" class="active">
        <span class="nav-icon"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg></span>
        Лекції
      </a>
      <a href="../../practicals.html">
        <span class="nav-icon"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg></span>
        Семінари
      </a>
      <a href="../../tests.html">
        <span class="nav-icon"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></span>
        Тести
      </a>
      <a href="../../materials.html">
        <span class="nav-icon"><svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/></svg></span>
        Матеріали
      </a>
    </nav>

    <div class="sidebar-footer">
      <button class="theme-toggle" onclick="toggleTheme()" aria-label="Перемкнути тему">
        <svg id="theme-icon" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" aria-hidden="true"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
        <span id="theme-label">Темна тема</span>
      </button>
    </div>
  </aside>

  <main>
    <div class="lecture-nav-top">
      <a href="../../lecture.html?id=5" class="back-link">← Назад до лекції</a>
      <span class="lecture-badge">Конспект</span>
    </div>

    <article class="lecture-content">
      <h1>Лекція 5. Безпека безсерверних обчислень (Serverless Security)</h1>
      <div class="lecture-info">
        <span><svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2" style="vertical-align: -2px; margin-right: 4px;"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>2 год</span>
      </div>

      <section>
        <h2>Вступ</h2>
        <p>Безсерверні обчислення (Serverless Computing) — це модель хмарних обчислень, яка революціонізує спосіб розробки та розгортання додатків. Незважаючи на назву, сервери все ще існують — просто розробники більше не турбуються про їхнє управління.</p>

        <p>У цій лекції ми розглянемо, як працює serverless, які унікальні безпекові виклики він створює, і як сучасні технології ізоляції (Firecracker, gVisor) забезпечують безпеку в multi-tenant середовищах.</p>

        <h3>Чому Serverless популярний?</h3>
        <ul>
          <li><strong>Немає управління інфраструктурою:</strong> провайдер керує серверами</li>
          <li><strong>Автоматичне масштабування:</strong> від 0 до мільйонів запитів</li>
          <li><strong>Pay-per-use:</strong> оплата тільки за фактичне виконання</li>
          <li><strong>Швидкий time-to-market:</strong> фокус на бізнес-логіці</li>
        </ul>

        <h3>Цілі лекції</h3>
        <p>Після цієї лекції ви зможете:</p>
        <ul>
          <li>Пояснити архітектуру serverless та різницю між FaaS і BaaS</li>
          <li>Ідентифікувати специфічні загрози та вразливості serverless-додатків</li>
          <li>Розуміти технології ізоляції: Firecracker, gVisor, Kata Containers</li>
          <li>Застосовувати best practices безпеки при розробці serverless-додатків</li>
        </ul>
      </section>

      <section>
        <h2>5.1 Архітектура Serverless</h2>

        <h3>Що таке Serverless?</h3>
        <p><strong>Serverless Computing</strong> — це модель виконання, де хмарний провайдер динамічно управляє виділенням та масштабуванням серверних ресурсів. Розробник пише код, а все інше — відповідальність провайдера.</p>

        <p>Ключові характеристики serverless:</p>
        <ul>
          <li><strong>Event-driven:</strong> код виконується у відповідь на події</li>
          <li><strong>Stateless:</strong> функції не зберігають стан між викликами</li>
          <li><strong>Ephemeral:</strong> контейнери створюються та знищуються динамічно</li>
          <li><strong>Auto-scaling:</strong> масштабування від 0 до необмеженої кількості</li>
          <li><strong>Pay-per-execution:</strong> оплата за кількість викликів та час виконання</li>
        </ul>

        <h3>FaaS — Function as a Service</h3>
        <p><strong>FaaS</strong> — основна модель serverless, де одиницею розгортання є функція — невеликий фрагмент коду, який виконує одну задачу.</p>

        <h4>Провайдери FaaS</h4>
        <table>
          <tr>
            <th>Провайдер</th>
            <th>Сервіс</th>
            <th>Особливості</th>
          </tr>
          <tr>
            <td>AWS</td>
            <td>Lambda</td>
            <td>Найпопулярніший, широка інтеграція з AWS сервісами</td>
          </tr>
          <tr>
            <td>Azure</td>
            <td>Functions</td>
            <td>Глибока інтеграція з .NET, Durable Functions</td>
          </tr>
          <tr>
            <td>Google Cloud</td>
            <td>Cloud Functions</td>
            <td>Cloud Run для контейнерів</td>
          </tr>
          <tr>
            <td>Cloudflare</td>
            <td>Workers</td>
            <td>Edge computing, V8 isolates</td>
          </tr>
        </table>

        <h4>Життєвий цикл Lambda функції</h4>
        <ol>
          <li><strong>Cold Start:</strong> Створення нового execution environment (контейнера)</li>
          <li><strong>Init:</strong> Завантаження коду, ініціалізація runtime</li>
          <li><strong>Invoke:</strong> Виконання handler функції</li>
          <li><strong>Warm:</strong> Контейнер залишається "теплим" для повторних викликів</li>
          <li><strong>Shutdown:</strong> Знищення контейнера після періоду неактивності</li>
        </ol>

        <p><strong>Cold Start</strong> — це затримка при першому виклику функції або після періоду неактивності. Час cold start залежить від:</p>
        <ul>
          <li>Мови програмування (Python, Node.js швидші за Java, .NET)</li>
          <li>Розміру пакету deployment</li>
          <li>VPC конфігурації</li>
          <li>Provisioned concurrency</li>
        </ul>

        <h3>BaaS — Backend as a Service</h3>
        <p><strong>BaaS</strong> — модель, де провайдер надає готові backend-компоненти як сервіси:</p>
        <ul>
          <li><strong>Authentication:</strong> AWS Cognito, Auth0, Firebase Auth</li>
          <li><strong>Database:</strong> Firebase Firestore, AWS DynamoDB</li>
          <li><strong>Storage:</strong> AWS S3, Firebase Storage</li>
          <li><strong>Messaging:</strong> AWS SNS/SQS, Firebase Cloud Messaging</li>
          <li><strong>API Gateway:</strong> AWS API Gateway, Azure API Management</li>
        </ul>

        <p>BaaS дозволяє будувати додатки майже без власного backend-коду, використовуючи готові сервіси.</p>

        <h3>Event-Driven Architecture</h3>
        <p>Serverless-додатки типово базуються на event-driven архітектурі:</p>

        <h4>Типи тригерів</h4>
        <ul>
          <li><strong>HTTP/API:</strong> REST API через API Gateway</li>
          <li><strong>Schedule:</strong> Cron-подібні scheduled events</li>
          <li><strong>Storage:</strong> Завантаження файлу в S3</li>
          <li><strong>Database:</strong> Зміни в DynamoDB Streams</li>
          <li><strong>Queue:</strong> Повідомлення в SQS, Kafka</li>
          <li><strong>IoT:</strong> Eventi від IoT пристроїв</li>
        </ul>

        <h3>Serverless vs Containers vs VMs</h3>

        <!-- Diagram: Abstraction Levels -->
        <div class="diagram">
          <div class="diagram-title">Рівні абстракції: від VM до Serverless</div>
          <svg viewBox="0 0 700 220" xmlns="http://www.w3.org/2000/svg">
            <!-- VM Stack -->
            <g transform="translate(30, 30)">
              <text class="diagram-text-bold" x="70" y="0" text-anchor="middle">VMs</text>
              <rect fill="#64748b" x="0" y="15" width="140" height="25" rx="4"/>
              <text fill="white" x="70" y="33" text-anchor="middle" font-size="9">Hardware</text>
              <rect fill="#475569" x="0" y="45" width="140" height="25" rx="4"/>
              <text fill="white" x="70" y="63" text-anchor="middle" font-size="9">Hypervisor</text>
              <rect fill="#3b82f6" x="0" y="75" width="140" height="25" rx="4"/>
              <text fill="white" x="70" y="93" text-anchor="middle" font-size="9">Guest OS</text>
              <rect fill="#60a5fa" x="0" y="105" width="140" height="25" rx="4"/>
              <text fill="white" x="70" y="123" text-anchor="middle" font-size="9">Runtime</text>
              <rect fill="#93c5fd" x="0" y="135" width="140" height="25" rx="4"/>
              <text fill="#1e3a8a" x="70" y="153" text-anchor="middle" font-size="9">Application</text>
              <rect fill="#fee2e2" stroke="#ef4444" stroke-dasharray="4,4" x="-5" y="10" width="150" height="155" rx="6"/>
              <text fill="#dc2626" x="70" y="180" text-anchor="middle" font-size="8">You manage</text>
            </g>

            <!-- Container Stack -->
            <g transform="translate(190, 30)">
              <text class="diagram-text-bold" x="70" y="0" text-anchor="middle">Containers</text>
              <rect fill="#64748b" x="0" y="15" width="140" height="25" rx="4"/>
              <text fill="white" x="70" y="33" text-anchor="middle" font-size="9">Hardware</text>
              <rect fill="#475569" x="0" y="45" width="140" height="25" rx="4"/>
              <text fill="white" x="70" y="63" text-anchor="middle" font-size="9">Host OS</text>
              <rect fill="#22c55e" x="0" y="75" width="140" height="25" rx="4"/>
              <text fill="white" x="70" y="93" text-anchor="middle" font-size="9">Container Runtime</text>
              <rect fill="#86efac" x="0" y="105" width="140" height="25" rx="4"/>
              <text fill="#166534" x="70" y="123" text-anchor="middle" font-size="9">Application + Deps</text>
              <rect fill="#fee2e2" stroke="#ef4444" stroke-dasharray="4,4" x="-5" y="70" width="150" height="65" rx="6"/>
              <text fill="#dc2626" x="70" y="180" text-anchor="middle" font-size="8">You manage</text>
            </g>

            <!-- Serverless Stack -->
            <g transform="translate(350, 30)">
              <text class="diagram-text-bold" x="70" y="0" text-anchor="middle">Serverless</text>
              <rect fill="#64748b" x="0" y="15" width="140" height="25" rx="4"/>
              <text fill="white" x="70" y="33" text-anchor="middle" font-size="9">Hardware</text>
              <rect fill="#475569" x="0" y="45" width="140" height="25" rx="4"/>
              <text fill="white" x="70" y="63" text-anchor="middle" font-size="9">Host OS</text>
              <rect fill="#8b5cf6" x="0" y="75" width="140" height="25" rx="4"/>
              <text fill="white" x="70" y="93" text-anchor="middle" font-size="9">Isolation (Firecracker)</text>
              <rect fill="#a78bfa" x="0" y="105" width="140" height="25" rx="4"/>
              <text fill="white" x="70" y="123" text-anchor="middle" font-size="9">Runtime (Node, Python)</text>
              <rect fill="#c4b5fd" x="0" y="135" width="140" height="25" rx="4"/>
              <text fill="#5b21b6" x="70" y="153" text-anchor="middle" font-size="9">Function Code</text>
              <rect fill="#fee2e2" stroke="#ef4444" stroke-dasharray="4,4" x="-5" y="130" width="150" height="35" rx="6"/>
              <text fill="#dc2626" x="70" y="180" text-anchor="middle" font-size="8">You manage</text>
            </g>

            <!-- Edge Functions Stack -->
            <g transform="translate(510, 30)">
              <text class="diagram-text-bold" x="70" y="0" text-anchor="middle">Edge (V8)</text>
              <rect fill="#64748b" x="0" y="15" width="140" height="25" rx="4"/>
              <text fill="white" x="70" y="33" text-anchor="middle" font-size="9">Hardware</text>
              <rect fill="#475569" x="0" y="45" width="140" height="25" rx="4"/>
              <text fill="white" x="70" y="63" text-anchor="middle" font-size="9">Host OS</text>
              <rect fill="#f59e0b" x="0" y="75" width="140" height="25" rx="4"/>
              <text fill="white" x="70" y="93" text-anchor="middle" font-size="9">V8 Engine</text>
              <rect fill="#fcd34d" x="0" y="105" width="140" height="25" rx="4"/>
              <text fill="#92400e" x="70" y="123" text-anchor="middle" font-size="9">Isolate</text>
              <rect fill="#fef3c7" x="0" y="135" width="140" height="25" rx="4"/>
              <text fill="#92400e" x="70" y="153" text-anchor="middle" font-size="9">JS/WASM Code</text>
              <rect fill="#fee2e2" stroke="#ef4444" stroke-dasharray="4,4" x="-5" y="130" width="150" height="35" rx="6"/>
              <text fill="#dc2626" x="70" y="180" text-anchor="middle" font-size="8">You manage</text>
            </g>

            <!-- Arrow showing abstraction increase -->
            <line stroke="var(--accent)" stroke-width="3" x1="30" y1="200" x2="650" y2="200" marker-end="url(#arrow-sls)"/>
            <text class="diagram-text-small" x="340" y="215" text-anchor="middle">Збільшення рівня абстракції / Зменшення управління</text>
          </svg>
          <div class="diagram-caption">Рис. 5.0. Еволюція абстракцій: від повного контролю (VM) до мінімального управління (Edge Functions)</div>
        </div>

        <!-- Diagram: Serverless Execution Flow -->
        <div class="diagram">
          <div class="diagram-title">Serverless: Event-Driven модель виконання</div>
          <svg viewBox="0 0 700 200" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <marker id="arrow-sls" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" fill="var(--accent)"/>
              </marker>
            </defs>

            <!-- Event Sources -->
            <text class="diagram-text-bold" x="80" y="25" text-anchor="middle">Event Sources</text>

            <rect fill="#fef3c7" stroke="#f59e0b" x="20" y="40" width="120" height="30" rx="6"/>
            <text fill="#b45309" x="80" y="60" text-anchor="middle" font-size="10">HTTP (API Gateway)</text>

            <rect fill="#dbeafe" stroke="#3b82f6" x="20" y="75" width="120" height="30" rx="6"/>
            <text fill="#1d4ed8" x="80" y="95" text-anchor="middle" font-size="10">S3 Upload</text>

            <rect fill="#dcfce7" stroke="#22c55e" x="20" y="110" width="120" height="30" rx="6"/>
            <text fill="#166534" x="80" y="130" text-anchor="middle" font-size="10">SQS/Queue</text>

            <rect fill="#fce7f3" stroke="#ec4899" x="20" y="145" width="120" height="30" rx="6"/>
            <text fill="#be185d" x="80" y="165" text-anchor="middle" font-size="10">Schedule (Cron)</text>

            <!-- Arrows to Function -->
            <line stroke="var(--accent)" stroke-width="2" x1="145" y1="55" x2="240" y2="95" marker-end="url(#arrow-sls)"/>
            <line stroke="var(--accent)" stroke-width="2" x1="145" y1="90" x2="240" y2="100" marker-end="url(#arrow-sls)"/>
            <line stroke="var(--accent)" stroke-width="2" x1="145" y1="125" x2="240" y2="105" marker-end="url(#arrow-sls)"/>
            <line stroke="var(--accent)" stroke-width="2" x1="145" y1="160" x2="240" y2="110" marker-end="url(#arrow-sls)"/>

            <!-- Function -->
            <rect fill="#8b5cf6" x="245" y="65" width="140" height="80" rx="12"/>
            <text fill="white" x="315" y="95" text-anchor="middle" font-weight="600" font-size="13">Lambda</text>
            <text fill="white" x="315" y="115" text-anchor="middle" font-size="10">(Function Code)</text>
            <text fill="white" x="315" y="132" text-anchor="middle" font-size="9">0ms → exec → terminate</text>

            <!-- Arrows to Outputs -->
            <line stroke="var(--accent)" stroke-width="2" x1="390" y1="95" x2="440" y2="55" marker-end="url(#arrow-sls)"/>
            <line stroke="var(--accent)" stroke-width="2" x1="390" y1="100" x2="440" y2="95" marker-end="url(#arrow-sls)"/>
            <line stroke="var(--accent)" stroke-width="2" x1="390" y1="110" x2="440" y2="135" marker-end="url(#arrow-sls)"/>

            <!-- Outputs -->
            <text class="diagram-text-bold" x="560" y="25" text-anchor="middle">Outputs / Side Effects</text>

            <rect fill="#dcfce7" stroke="#22c55e" x="445" y="40" width="120" height="30" rx="6"/>
            <text fill="#166534" x="505" y="60" text-anchor="middle" font-size="10">DynamoDB Write</text>

            <rect fill="#dbeafe" stroke="#3b82f6" x="445" y="80" width="120" height="30" rx="6"/>
            <text fill="#1d4ed8" x="505" y="100" text-anchor="middle" font-size="10">HTTP Response</text>

            <rect fill="#fef3c7" stroke="#f59e0b" x="445" y="120" width="120" height="30" rx="6"/>
            <text fill="#b45309" x="505" y="140" text-anchor="middle" font-size="10">SNS Notification</text>

            <!-- Scaling indicator -->
            <g transform="translate(580, 50)">
              <rect fill="var(--card)" stroke="var(--card-border)" x="0" y="0" width="100" height="120" rx="8"/>
              <text class="diagram-text-small" x="50" y="20" text-anchor="middle">Auto-scale</text>
              <rect fill="#8b5cf6" opacity="0.5" x="10" y="30" width="25" height="15" rx="3"/>
              <rect fill="#8b5cf6" opacity="0.6" x="10" y="48" width="25" height="15" rx="3"/>
              <rect fill="#8b5cf6" opacity="0.7" x="10" y="66" width="25" height="15" rx="3"/>
              <rect fill="#8b5cf6" opacity="0.8" x="10" y="84" width="25" height="15" rx="3"/>
              <rect fill="#8b5cf6" x="10" y="102" width="25" height="10" rx="2"/>
              <text class="diagram-text-small" x="60" y="70" text-anchor="start">×1000</text>
              <text class="diagram-text-small" x="60" y="85" text-anchor="start">instances</text>
            </g>
          </svg>
          <div class="diagram-caption">Рис. 5.1. Serverless (FaaS): події запускають функції, які автоматично масштабуються від 0 до тисяч екземплярів</div>
        </div>

        <table>
          <tr>
            <th>Аспект</th>
            <th>VMs</th>
            <th>Containers</th>
            <th>Serverless</th>
          </tr>
          <tr>
            <td>Абстракція</td>
            <td>Hardware</td>
            <td>OS</td>
            <td>Runtime</td>
          </tr>
          <tr>
            <td>Масштабування</td>
            <td>Хвилини</td>
            <td>Секунди</td>
            <td>Мілісекунди</td>
          </tr>
          <tr>
            <td>Управління</td>
            <td>Повне</td>
            <td>Часткове</td>
            <td>Мінімальне</td>
          </tr>
          <tr>
            <td>Стан</td>
            <td>Stateful</td>
            <td>Stateful/Stateless</td>
            <td>Stateless</td>
          </tr>
          <tr>
            <td>Оплата</td>
            <td>За час роботи</td>
            <td>За час роботи</td>
            <td>За виконання</td>
          </tr>
          <tr>
            <td>Cold Start</td>
            <td>Хвилини</td>
            <td>Секунди</td>
            <td>Мілісекунди-секунди</td>
          </tr>
        </table>

        <h3>Shared Responsibility в Serverless</h3>
        <p>У serverless-моделі розподіл відповідальності суттєво зміщується до провайдера:</p>

        <h4>Провайдер відповідає за:</h4>
        <ul>
          <li>Фізичну безпеку</li>
          <li>Гіпервізор та ізоляцію</li>
          <li>Операційну систему</li>
          <li>Runtime середовище</li>
          <li>Патчі та оновлення</li>
        </ul>

        <h4>Клієнт відповідає за:</h4>
        <ul>
          <li>Код функції</li>
          <li>Залежності та бібліотеки</li>
          <li>IAM та дозволи</li>
          <li>Дані та їх шифрування</li>
          <li>Конфігурацію (env variables, timeouts)</li>
        </ul>
      </section>

      <section>
        <h2>5.2 Загрози та вразливості Serverless</h2>

        <h3>OWASP Serverless Top 10</h3>
        <p>OWASP випустив специфічний список загроз для serverless-додатків:</p>

        <h4>1. Injection (Ін'єкції)</h4>
        <p>Класичні ін'єкції залишаються актуальними:</p>
        <ul>
          <li><strong>SQL Injection:</strong> при взаємодії з базами даних</li>
          <li><strong>NoSQL Injection:</strong> DynamoDB, MongoDB</li>
          <li><strong>OS Command Injection:</strong> при виклику системних команд</li>
          <li><strong>Event Injection:</strong> специфічна для serverless — маніпуляція event data</li>
        </ul>

        <pre>
// Вразливий код — event injection
exports.handler = async (event) => {
  const filename = event.queryStringParameters.file;
  // Атакуючий може передати: ../../../etc/passwd
  const data = fs.readFileSync('/tmp/' + filename);
  return { body: data.toString() };
};
        </pre>

        <h4>2. Broken Authentication</h4>
        <p>Проблеми з автентифікацією в serverless:</p>
        <ul>
          <li>Відсутність автентифікації для internal functions</li>
          <li>Слабка валідація JWT токенів</li>
          <li>Hardcoded credentials в коді</li>
          <li>Неправильна конфігурація API Gateway authorizers</li>
        </ul>

        <h4>3. Sensitive Data Exposure</h4>
        <ul>
          <li>Секрети в environment variables (видимі в console)</li>
          <li>Логування чутливих даних</li>
          <li>Незашифровані дані в transit</li>
          <li>Витік через error messages</li>
        </ul>

        <h4>4. Denial of Service (DoS)</h4>
        <p>Serverless має специфічні DoS-вектори:</p>
        <ul>
          <li><strong>Financial DoS:</strong> атакуючий викликає функцію мільйони разів — величезний рахунок</li>
          <li><strong>Concurrency Exhaustion:</strong> вичерпання ліміту одночасних виконань</li>
          <li><strong>Downstream DoS:</strong> функція атакує backend-сервіси</li>
          <li><strong>ReDoS:</strong> Regex Denial of Service через складні патерни</li>
        </ul>

        <h4>5. Broken Access Control</h4>
        <ul>
          <li>Занадто широкі IAM permissions</li>
          <li>Відсутність перевірки прав на рівні функції</li>
          <li>Insecure Direct Object Reference (IDOR)</li>
        </ul>

        <h4>6. Security Misconfiguration</h4>
        <ul>
          <li>Публічні S3 buckets</li>
          <li>Відкриті API endpoints</li>
          <li>Debug mode в production</li>
          <li>Default configurations</li>
        </ul>

        <h4>7. Insufficient Logging & Monitoring</h4>
        <p>Розподілена природа serverless ускладнює моніторинг:</p>
        <ul>
          <li>Логи розкидані по різних сервісах</li>
          <li>Складність трасування запитів</li>
          <li>Ephemeral nature — контейнери зникають</li>
        </ul>

        <h4>8. Insecure Third-Party Dependencies</h4>
        <ul>
          <li>Вразливі npm/pip пакети</li>
          <li>Supply chain attacks</li>
          <li>Outdated dependencies</li>
        </ul>

        <h4>9. Improper Exception Handling</h4>
        <ul>
          <li>Stack traces в відповідях</li>
          <li>Витік internal paths</li>
          <li>Uncaught exceptions</li>
        </ul>

        <h4>10. Inadequate Function Permissions</h4>
        <ul>
          <li>Overly permissive execution roles</li>
          <li>Cross-function privilege escalation</li>
          <li>Resource-based policy misconfigurations</li>
        </ul>

        <h3>Специфічні атаки на Serverless</h3>

        <h4>Event Data Injection</h4>
        <p>Атакуючий маніпулює даними події, яка тригерить функцію:</p>
        <pre>
// S3 event injection
// Атакуючий створює файл з назвою: "; rm -rf /tmp/*; #.jpg"
exports.handler = async (event) => {
  const bucket = event.Records[0].s3.bucket.name;
  const key = event.Records[0].s3.object.key;
  // Вразливо!
  exec(`convert /tmp/${key} /tmp/thumbnail-${key}`);
};
        </pre>

        <h4>Poisoned Function</h4>
        <p>Експлуатація warm containers — код зберігається між викликами:</p>
        <ul>
          <li>Атакуючий модифікує глобальні змінні</li>
          <li>Впливає на наступні виклики того ж контейнера</li>
          <li>Важко виявити — залежить від того, який контейнер обробить запит</li>
        </ul>

        <h4>Cross-Tenant Attacks</h4>
        <p>В multi-tenant середовищі можливі атаки між клієнтами:</p>
        <ul>
          <li>Side-channel attacks на shared infrastructure</li>
          <li>Timing attacks</li>
          <li>Resource exhaustion, що впливає на сусідів</li>
        </ul>

        <h3>Реальні інциденти</h3>

        <h4>Capital One Breach (2019)</h4>
        <p>Один з найбільших cloud breaches був пов'язаний з serverless:</p>
        <ul>
          <li>WAF misconfiguration дозволив SSRF атаку</li>
          <li>Lambda функція мала занадто широкі IAM права</li>
          <li>Атакуючий отримав доступ до metadata service</li>
          <li>Вкрадено дані 100+ мільйонів клієнтів</li>
          <li><strong>Урок:</strong> Principle of Least Privilege критичний</li>
        </ul>

        <!-- Diagram: Capital One Attack Flow -->
        <div class="diagram">
          <div class="diagram-title">Capital One Breach: Attack Flow через SSRF</div>
          <svg viewBox="0 0 700 200" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <marker id="arrow-cap" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" fill="#ef4444"/>
              </marker>
            </defs>

            <!-- Attacker -->
            <g transform="translate(30, 60)">
              <circle fill="#fecaca" stroke="#ef4444" cx="35" cy="35" r="30"/>
              <text fill="#dc2626" x="35" y="40" text-anchor="middle" font-size="10">Attacker</text>
              <text fill="#dc2626" x="35" y="85" text-anchor="middle" font-size="8">Paige Thompson</text>
            </g>

            <!-- Step 1: WAF -->
            <g transform="translate(130, 50)">
              <rect fill="#fee2e2" stroke="#ef4444" x="0" y="0" width="90" height="55" rx="6"/>
              <text fill="#dc2626" x="45" y="25" text-anchor="middle" font-size="9">ModSecurity</text>
              <text fill="#dc2626" x="45" y="40" text-anchor="middle" font-size="9">WAF</text>
              <text fill="#991b1b" x="45" y="70" text-anchor="middle" font-size="7">Misconfigured!</text>
            </g>
            <line stroke="#ef4444" stroke-width="2" x1="95" y1="95" x2="130" y2="77" marker-end="url(#arrow-cap)"/>
            <text fill="#ef4444" x="112" y="75" text-anchor="middle" font-size="7">1. SSRF</text>

            <!-- Step 2: Lambda -->
            <g transform="translate(250, 50)">
              <rect fill="#fef3c7" stroke="#f59e0b" x="0" y="0" width="90" height="55" rx="6"/>
              <text fill="#b45309" x="45" y="25" text-anchor="middle" font-size="9">Lambda</text>
              <text fill="#b45309" x="45" y="40" text-anchor="middle" font-size="9">Function</text>
              <text fill="#92400e" x="45" y="70" text-anchor="middle" font-size="7">Overly permissive IAM</text>
            </g>
            <line stroke="#ef4444" stroke-width="2" x1="220" y1="77" x2="250" y2="77" marker-end="url(#arrow-cap)"/>
            <text fill="#ef4444" x="235" y="65" text-anchor="middle" font-size="7">2. Request</text>

            <!-- Step 3: Metadata -->
            <g transform="translate(370, 50)">
              <rect fill="#dbeafe" stroke="#3b82f6" x="0" y="0" width="90" height="55" rx="6"/>
              <text fill="#1d4ed8" x="45" y="25" text-anchor="middle" font-size="9">Metadata</text>
              <text fill="#1d4ed8" x="45" y="40" text-anchor="middle" font-size="9">169.254.169.254</text>
            </g>
            <line stroke="#ef4444" stroke-width="2" x1="340" y1="77" x2="370" y2="77" marker-end="url(#arrow-cap)"/>
            <text fill="#ef4444" x="355" y="65" text-anchor="middle" font-size="7">3. SSRF</text>

            <!-- Step 4: IAM Creds -->
            <g transform="translate(370, 120)">
              <rect fill="#fecaca" stroke="#ef4444" x="0" y="0" width="90" height="40" rx="6"/>
              <text fill="#dc2626" x="45" y="18" text-anchor="middle" font-size="9">IAM Creds</text>
              <text fill="#dc2626" x="45" y="32" text-anchor="middle" font-size="9">Stolen!</text>
            </g>
            <line stroke="#ef4444" stroke-width="2" x1="415" y1="105" x2="415" y2="120" marker-end="url(#arrow-cap)"/>
            <text fill="#ef4444" x="430" y="113" text-anchor="middle" font-size="7">4. Creds</text>

            <!-- Step 5: S3 -->
            <g transform="translate(500, 50)">
              <rect fill="#dcfce7" stroke="#22c55e" x="0" y="0" width="90" height="55" rx="6"/>
              <text fill="#166534" x="45" y="25" text-anchor="middle" font-size="9">S3 Buckets</text>
              <text fill="#166534" x="45" y="40" text-anchor="middle" font-size="9">Customer Data</text>
            </g>
            <line stroke="#ef4444" stroke-width="2" x1="460" y1="140" x2="500" y2="100" marker-end="url(#arrow-cap)"/>
            <text fill="#ef4444" x="475" y="130" text-anchor="middle" font-size="7">5. Access</text>

            <!-- Result -->
            <g transform="translate(600, 70)">
              <text fill="#dc2626" x="50" y="0" text-anchor="middle" font-weight="600" font-size="10">106M records</text>
              <text fill="#dc2626" x="50" y="15" text-anchor="middle" font-size="9">compromised</text>
              <text fill="#dc2626" x="50" y="35" text-anchor="middle" font-size="9">$80M fine</text>
            </g>
          </svg>
          <div class="diagram-caption">Рис. 5.2. Анатомія Capital One breach: SSRF через misconfigured WAF дозволив доступ до metadata та S3</div>
        </div>

        <h4>Правильний захист від SSRF у Lambda</h4>
        <pre>
# IMDSv2 вимагає токен — блокує простий SSRF
# Увімкніть IMDSv2 для всіх EC2/Lambda:

# AWS CLI
aws ec2 modify-instance-metadata-options \
  --instance-id i-1234567890abcdef0 \
  --http-tokens required \
  --http-endpoint enabled

# Terraform
resource "aws_instance" "example" {
  metadata_options {
    http_tokens   = "required"  # IMDSv2 only
    http_endpoint = "enabled"
  }
}

# Lambda — використовуйте IAM roles з мінімальними правами:
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": ["s3:GetObject"],
      "Resource": "arn:aws:s3:::specific-bucket/specific-prefix/*"
    }
  ]
}
        </pre>

        <h3>Статистика serverless-інцидентів</h3>
        <table>
          <tr>
            <th>Тип вразливості</th>
            <th>% інцидентів</th>
            <th>Середній вплив</th>
          </tr>
          <tr>
            <td>Overly permissive IAM</td>
            <td>35%</td>
            <td>Критичний</td>
          </tr>
          <tr>
            <td>Secrets in code/env</td>
            <td>25%</td>
            <td>Високий</td>
          </tr>
          <tr>
            <td>Vulnerable dependencies</td>
            <td>20%</td>
            <td>Середній-Високий</td>
          </tr>
          <tr>
            <td>Injection attacks</td>
            <td>12%</td>
            <td>Високий</td>
          </tr>
          <tr>
            <td>Insufficient logging</td>
            <td>8%</td>
            <td>Середній</td>
          </tr>
        </table>
      </section>

      <section>
        <h2>5.3 Технології ізоляції</h2>

        <h3>Проблема Multi-tenancy</h3>
        <p>Serverless платформи виконують код від тисяч різних клієнтів на спільній інфраструктурі. Це створює критичну потребу в сильній ізоляції.</p>

        <p>Традиційні контейнери (Docker) не забезпечують достатньої ізоляції для multi-tenant serverless:</p>
        <ul>
          <li>Спільне ядро — вразливість ядра = компрометація всіх</li>
          <li>Container escape можливий</li>
          <li>Не призначені для недовірених workloads</li>
        </ul>

        <h3>AWS Firecracker</h3>
        <p><strong>Firecracker</strong> — це lightweight Virtual Machine Monitor (VMM), розроблений AWS для serverless workloads. Він поєднує безпеку VM з швидкістю контейнерів.</p>

        <h4>Ключові характеристики</h4>
        <ul>
          <li><strong>microVM:</strong> мінімальна VM з власним ядром</li>
          <li><strong>Швидкість:</strong> cold start < 125ms</li>
          <li><strong>Мінімальний footprint:</strong> ~5MB RAM overhead</li>
          <li><strong>Security-first design:</strong> мінімальна поверхня атаки</li>
          <li><strong>Написаний на Rust:</strong> memory safety</li>
        </ul>

        <h4>Архітектура Firecracker</h4>
        <pre>
┌─────────────────────────────────────────────┐
│              Host Machine                    │
│  ┌─────────────┐  ┌─────────────┐           │
│  │  microVM 1  │  │  microVM 2  │  ...      │
│  │ ┌─────────┐ │  │ ┌─────────┐ │           │
│  │ │ Lambda  │ │  │ │ Lambda  │ │           │
│  │ │ Function│ │  │ │ Function│ │           │
│  │ └─────────┘ │  │ └─────────┘ │           │
│  │   Guest OS  │  │   Guest OS  │           │
│  │   (Linux)   │  │   (Linux)   │           │
│  └──────┬──────┘  └──────┬──────┘           │
│         │                │                   │
│  ┌──────┴────────────────┴──────┐           │
│  │        Firecracker VMM        │           │
│  └──────────────┬────────────────┘           │
│                 │                            │
│  ┌──────────────┴────────────────┐           │
│  │           Host Kernel          │           │
│  └────────────────────────────────┘           │
└─────────────────────────────────────────────┘
        </pre>

        <h4>Безпека Firecracker</h4>
        <ul>
          <li><strong>Кожна функція в окремій VM:</strong> повна ізоляція ядра</li>
          <li><strong>Jailer:</strong> додатковий рівень sandboxing</li>
          <li><strong>Seccomp filters:</strong> обмеження системних викликів</li>
          <li><strong>Мінімальний device model:</strong> тільки virtio-net, virtio-block</li>
          <li><strong>No hardware passthrough:</strong> немає доступу до фізичних пристроїв</li>
        </ul>

        <h4>Використання</h4>
        <ul>
          <li><strong>AWS Lambda:</strong> основна технологія ізоляції</li>
          <li><strong>AWS Fargate:</strong> для контейнерів</li>
          <li><strong>Open Source:</strong> можна використовувати самостійно</li>
        </ul>

        <h3>Google gVisor</h3>
        <p><strong>gVisor</strong> — це application kernel від Google, який забезпечує ізоляцію через перехоплення системних викликів.</p>

        <h4>Архітектура gVisor</h4>
        <pre>
┌─────────────────────────────────────────────┐
│              Container                       │
│  ┌─────────────────────────────────────┐    │
│  │           Application                │    │
│  └──────────────┬──────────────────────┘    │
│                 │ syscalls                   │
│  ┌──────────────┴──────────────────────┐    │
│  │             Sentry                   │    │
│  │      (User-space Kernel)             │    │
│  └──────────────┬──────────────────────┘    │
│                 │ limited syscalls          │
│  ┌──────────────┴──────────────────────┐    │
│  │             Gofer                    │    │
│  │      (File System Proxy)             │    │
│  └──────────────┬──────────────────────┘    │
└─────────────────┼───────────────────────────┘
                  │
┌─────────────────┴───────────────────────────┐
│              Host Kernel                     │
└─────────────────────────────────────────────┘
        </pre>

        <h4>Компоненти gVisor</h4>
        <ul>
          <li><strong>Sentry:</strong> User-space kernel, що реалізує Linux syscall interface</li>
          <li><strong>Gofer:</strong> File system proxy для доступу до файлів</li>
          <li><strong>runsc:</strong> OCI-compatible container runtime</li>
        </ul>

        <h4>Безпека gVisor</h4>
        <ul>
          <li><strong>Reduced attack surface:</strong> application не має прямого доступу до host kernel</li>
          <li><strong>Defense in depth:</strong> навіть якщо Sentry компрометований, host kernel захищений</li>
          <li><strong>Seccomp:</strong> обмежений набір syscalls до host</li>
          <li><strong>Написаний на Go:</strong> memory safety</li>
        </ul>

        <h4>Обмеження</h4>
        <ul>
          <li>Не всі syscalls підтримані (близько 70%)</li>
          <li>Performance overhead (особливо I/O)</li>
          <li>Деякі додатки можуть не працювати</li>
        </ul>

        <h4>Використання</h4>
        <ul>
          <li><strong>Google Cloud Run:</strong> опція sandboxed containers</li>
          <li><strong>GKE Sandbox:</strong> для Kubernetes pods</li>
          <li><strong>Open Source:</strong> можна інтегрувати з Docker/Kubernetes</li>
        </ul>

        <h3>Kata Containers</h3>
        <p><strong>Kata Containers</strong> — проект, що поєднує легкість контейнерів з безпекою VM.</p>

        <h4>Ключові особливості</h4>
        <ul>
          <li>Кожен контейнер/pod в окремій lightweight VM</li>
          <li>OCI-compatible runtime</li>
          <li>Підтримує різні гіпервізори (QEMU, Firecracker, Cloud Hypervisor)</li>
          <li>Інтеграція з Kubernetes через CRI</li>
        </ul>

        <h4>Порівняння</h4>
        <table>
          <tr>
            <th>Характеристика</th>
            <th>Firecracker</th>
            <th>gVisor</th>
            <th>Kata</th>
          </tr>
          <tr>
            <td>Тип ізоляції</td>
            <td>microVM</td>
            <td>User-space kernel</td>
            <td>Lightweight VM</td>
          </tr>
          <tr>
            <td>Cold start</td>
            <td>~125ms</td>
            <td>~150ms</td>
            <td>~500ms</td>
          </tr>
          <tr>
            <td>Memory overhead</td>
            <td>~5MB</td>
            <td>~50MB</td>
            <td>~100MB</td>
          </tr>
          <tr>
            <td>Compatibility</td>
            <td>Висока</td>
            <td>Середня (~70%)</td>
            <td>Висока</td>
          </tr>
          <tr>
            <td>Використовується</td>
            <td>AWS Lambda</td>
            <td>GCP Cloud Run</td>
            <td>OpenStack, Kubernetes</td>
          </tr>
        </table>

        <h3>Cloudflare Workers: V8 Isolates</h3>
        <p>Cloudflare використовує інший підхід — <strong>V8 Isolates</strong>:</p>
        <ul>
          <li>JavaScript/WASM виконується в ізольованих V8 contexts</li>
          <li>Не потрібні контейнери чи VM</li>
          <li>Надзвичайно швидкий cold start (< 5ms)</li>
          <li>Менший overhead</li>
          <li>Обмеження: тільки JavaScript/WASM</li>
        </ul>

        <!-- Diagram: Isolation Technologies Comparison -->
        <div class="diagram">
          <div class="diagram-title">Порівняння технологій ізоляції Serverless</div>
          <svg viewBox="0 0 700 280" xmlns="http://www.w3.org/2000/svg">
            <!-- Firecracker -->
            <g transform="translate(30, 30)">
              <rect fill="#fef3c7" stroke="#f59e0b" stroke-width="2" x="0" y="0" width="200" height="230" rx="10"/>
              <text fill="#b45309" x="100" y="25" text-anchor="middle" font-weight="600" font-size="13">Firecracker</text>
              <text fill="#92400e" x="100" y="45" text-anchor="middle" font-size="10">(AWS Lambda)</text>

              <rect fill="var(--card)" stroke="var(--card-border)" x="15" y="60" width="170" height="40" rx="6"/>
              <text class="diagram-text-small" x="100" y="75" text-anchor="middle">Function Code</text>
              <text class="diagram-text-small" x="100" y="90" text-anchor="middle">+ Runtime</text>

              <rect fill="#fcd34d" x="15" y="105" width="170" height="30" rx="4"/>
              <text fill="#92400e" x="100" y="125" text-anchor="middle" font-size="10">Guest Kernel (Linux)</text>

              <rect fill="#f59e0b" x="15" y="140" width="170" height="30" rx="4"/>
              <text fill="white" x="100" y="160" text-anchor="middle" font-size="10">microVM (KVM)</text>

              <rect fill="#64748b" x="15" y="175" width="170" height="25" rx="4"/>
              <text fill="white" x="100" y="192" text-anchor="middle" font-size="10">Host Kernel</text>

              <text fill="#92400e" x="100" y="220" text-anchor="middle" font-size="9">Cold start: ~125ms</text>
            </g>

            <!-- gVisor -->
            <g transform="translate(250, 30)">
              <rect fill="#dbeafe" stroke="#3b82f6" stroke-width="2" x="0" y="0" width="200" height="230" rx="10"/>
              <text fill="#1d4ed8" x="100" y="25" text-anchor="middle" font-weight="600" font-size="13">gVisor</text>
              <text fill="#1e40af" x="100" y="45" text-anchor="middle" font-size="10">(GCP Cloud Run)</text>

              <rect fill="var(--card)" stroke="var(--card-border)" x="15" y="60" width="170" height="40" rx="6"/>
              <text class="diagram-text-small" x="100" y="75" text-anchor="middle">Application</text>
              <text class="diagram-text-small" x="100" y="90" text-anchor="middle">+ Container Image</text>

              <rect fill="#93c5fd" x="15" y="105" width="170" height="40" rx="4"/>
              <text fill="#1e3a8a" x="100" y="120" text-anchor="middle" font-size="10">Sentry</text>
              <text fill="#1e3a8a" x="100" y="135" text-anchor="middle" font-size="9">(User-space kernel)</text>

              <rect fill="#3b82f6" x="15" y="150" width="170" height="20" rx="4"/>
              <text fill="white" x="100" y="165" text-anchor="middle" font-size="9">Gofer (FS proxy)</text>

              <rect fill="#64748b" x="15" y="175" width="170" height="25" rx="4"/>
              <text fill="white" x="100" y="192" text-anchor="middle" font-size="10">Host Kernel</text>

              <text fill="#1e40af" x="100" y="220" text-anchor="middle" font-size="9">Cold start: ~150ms</text>
            </g>

            <!-- V8 Isolates -->
            <g transform="translate(470, 30)">
              <rect fill="#dcfce7" stroke="#22c55e" stroke-width="2" x="0" y="0" width="200" height="230" rx="10"/>
              <text fill="#166534" x="100" y="25" text-anchor="middle" font-weight="600" font-size="13">V8 Isolates</text>
              <text fill="#14532d" x="100" y="45" text-anchor="middle" font-size="10">(Cloudflare Workers)</text>

              <rect fill="var(--card)" stroke="var(--card-border)" x="15" y="60" width="75" height="50" rx="6"/>
              <text class="diagram-text-small" x="52" y="85" text-anchor="middle">Worker</text>
              <text class="diagram-text-small" x="52" y="100" text-anchor="middle">A</text>

              <rect fill="var(--card)" stroke="var(--card-border)" x="110" y="60" width="75" height="50" rx="6"/>
              <text class="diagram-text-small" x="147" y="85" text-anchor="middle">Worker</text>
              <text class="diagram-text-small" x="147" y="100" text-anchor="middle">B</text>

              <rect fill="#86efac" x="15" y="115" width="170" height="55" rx="4"/>
              <text fill="#166534" x="100" y="135" text-anchor="middle" font-size="10">V8 Engine</text>
              <text fill="#166534" x="100" y="150" text-anchor="middle" font-size="9">+ Isolate Contexts</text>
              <text fill="#166534" x="100" y="163" text-anchor="middle" font-size="8">(same process)</text>

              <rect fill="#64748b" x="15" y="175" width="170" height="25" rx="4"/>
              <text fill="white" x="100" y="192" text-anchor="middle" font-size="10">Host Kernel</text>

              <text fill="#14532d" x="100" y="220" text-anchor="middle" font-size="9">Cold start: ~5ms (!)</text>
            </g>
          </svg>
          <div class="diagram-caption">Рис. 5.3. Різні підходи до ізоляції: microVM (найсильніша), user-space kernel, V8 isolates (найшвидший)</div>
        </div>

        <h3>Вибір технології ізоляції</h3>
        <table>
          <tr>
            <th>Критерій</th>
            <th>Firecracker</th>
            <th>gVisor</th>
            <th>V8 Isolates</th>
          </tr>
          <tr>
            <td><strong>Рівень ізоляції</strong></td>
            <td>Найвищий (окреме ядро)</td>
            <td>Високий (user-space kernel)</td>
            <td>Середній (process isolation)</td>
          </tr>
          <tr>
            <td><strong>Cold start</strong></td>
            <td>~125ms</td>
            <td>~150ms</td>
            <td>~5ms</td>
          </tr>
          <tr>
            <td><strong>Підтримка мов</strong></td>
            <td>Будь-які</td>
            <td>Будь-які (Linux)</td>
            <td>Тільки JS/WASM</td>
          </tr>
          <tr>
            <td><strong>Syscall compatibility</strong></td>
            <td>100%</td>
            <td>~70%</td>
            <td>N/A (Web APIs)</td>
          </tr>
          <tr>
            <td><strong>Memory overhead</strong></td>
            <td>~5MB</td>
            <td>~50MB</td>
            <td>~1MB</td>
          </tr>
          <tr>
            <td><strong>Use case</strong></td>
            <td>General serverless</td>
            <td>Container sandboxing</td>
            <td>Edge computing</td>
          </tr>
        </table>
      </section>

      <section>
        <h2>5.4 Best Practices безпеки Serverless</h2>

        <h3>Principle of Least Privilege</h3>
        <p>Найважливіший принцип для serverless — кожна функція має мати мінімально необхідні права.</p>

        <pre>
# Погано — занадто широкі права
{
  "Effect": "Allow",
  "Action": "s3:*",
  "Resource": "*"
}

# Добре — конкретні права на конкретний ресурс
{
  "Effect": "Allow",
  "Action": ["s3:GetObject"],
  "Resource": "arn:aws:s3:::my-bucket/uploads/*"
}
        </pre>

        <h4>Рекомендації IAM</h4>
        <ul>
          <li>Окрема IAM role для кожної функції</li>
          <li>Використовуйте resource-based conditions</li>
          <li>Регулярно аудитуйте permissions</li>
          <li>Використовуйте AWS IAM Access Analyzer</li>
        </ul>

        <h3>Secure Dependencies</h3>
        <ul>
          <li><strong>Мінімізуйте залежності:</strong> менше коду = менша поверхня атаки</li>
          <li><strong>Скануйте на вразливості:</strong> npm audit, pip-audit, Snyk</li>
          <li><strong>Lock versions:</strong> package-lock.json, requirements.txt з версіями</li>
          <li><strong>Регулярні оновлення:</strong> автоматизуйте через Dependabot</li>
        </ul>

        <h3>Input Validation</h3>
        <pre>
// Валідація вхідних даних
exports.handler = async (event) => {
  // Валідуйте та санітизуйте всі inputs
  const userId = event.pathParameters?.userId;

  if (!userId || !/^[a-zA-Z0-9-]+$/.test(userId)) {
    return {
      statusCode: 400,
      body: JSON.stringify({ error: 'Invalid user ID' })
    };
  }

  // Безпечно використовуйте після валідації
  const user = await getUser(userId);
  // ...
};
        </pre>

        <h3>Secrets Management</h3>
        <ul>
          <li><strong>Не в коді:</strong> ніколи не hardcode секрети</li>
          <li><strong>Не в environment variables:</strong> для чутливих даних</li>
          <li><strong>AWS Secrets Manager:</strong> або SSM Parameter Store</li>
          <li><strong>Runtime retrieval:</strong> отримуйте секрети при виконанні</li>
        </ul>

        <pre>
// Отримання секрету з AWS Secrets Manager
const { SecretsManagerClient, GetSecretValueCommand } = require("@aws-sdk/client-secrets-manager");

const client = new SecretsManagerClient();

let cachedSecret = null;

async function getSecret() {
  if (cachedSecret) return cachedSecret;

  const command = new GetSecretValueCommand({
    SecretId: "my-app/database-credentials"
  });

  const response = await client.send(command);
  cachedSecret = JSON.parse(response.SecretString);
  return cachedSecret;
}
        </pre>

        <h3>Logging та Monitoring</h3>
        <ul>
          <li><strong>Structured logging:</strong> JSON формат для easy parsing</li>
          <li><strong>Correlation IDs:</strong> трасування через distributed system</li>
          <li><strong>Не логуйте sensitive data:</strong> паролі, tokens, PII</li>
          <li><strong>Централізований logging:</strong> CloudWatch, Datadog</li>
        </ul>

        <pre>
// Structured logging з correlation ID
exports.handler = async (event, context) => {
  const correlationId = event.headers?.['x-correlation-id'] || context.awsRequestId;

  console.log(JSON.stringify({
    level: 'INFO',
    correlationId,
    message: 'Processing request',
    userId: event.pathParameters?.userId,
    // НЕ логуємо sensitive data!
  }));

  // ...
};
        </pre>

        <h3>API Gateway Security</h3>
        <ul>
          <li><strong>Authentication:</strong> Cognito, Lambda Authorizers</li>
          <li><strong>Rate Limiting:</strong> захист від DoS</li>
          <li><strong>WAF:</strong> захист від common attacks</li>
          <li><strong>Request validation:</strong> на рівні API Gateway</li>
          <li><strong>CORS:</strong> правильна конфігурація</li>
        </ul>

        <h3>Function Configuration</h3>
        <ul>
          <li><strong>Timeout:</strong> встановіть розумний timeout (не максимальний)</li>
          <li><strong>Memory:</strong> right-size пам'ять</li>
          <li><strong>Concurrency limits:</strong> захист від runaway costs</li>
          <li><strong>Reserved concurrency:</strong> для critical functions</li>
          <li><strong>Dead Letter Queue:</strong> для failed invocations</li>
        </ul>

        <h3>Network Security</h3>
        <ul>
          <li><strong>VPC:</strong> розміщуйте функції у VPC для доступу до internal resources</li>
          <li><strong>VPC Endpoints:</strong> private access до AWS сервісів</li>
          <li><strong>Security Groups:</strong> обмежуйте outbound traffic</li>
          <li><strong>НЕ в VPC:</strong> якщо не потрібен доступ до VPC resources (швидший cold start)</li>
        </ul>

        <h3>CI/CD Security</h3>
        <ul>
          <li><strong>Infrastructure as Code:</strong> SAM, Serverless Framework, Terraform</li>
          <li><strong>Policy-as-Code:</strong> AWS Config Rules, OPA</li>
          <li><strong>Automated scanning:</strong> в CI/CD pipeline</li>
          <li><strong>Staging environments:</strong> тестування перед production</li>
        </ul>

        <h3>Serverless Security Checklist</h3>
        <ul>
          <li>☐ Окрема IAM role для кожної функції</li>
          <li>☐ Least privilege permissions</li>
          <li>☐ Input validation на всіх endpoints</li>
          <li>☐ Secrets в Secrets Manager, не в env vars</li>
          <li>☐ Залежності скановані на вразливості</li>
          <li>☐ Structured logging без sensitive data</li>
          <li>☐ API Gateway з authentication та rate limiting</li>
          <li>☐ Timeouts та concurrency limits встановлені</li>
          <li>☐ VPC тільки якщо необхідно</li>
          <li>☐ Моніторинг та алерти налаштовані</li>
        </ul>

        <h3>Порівняння serverless-рішень за безпекою</h3>
        <table>
          <tr>
            <th>Аспект безпеки</th>
            <th>AWS Lambda</th>
            <th>Azure Functions</th>
            <th>GCP Cloud Functions</th>
            <th>Cloudflare Workers</th>
          </tr>
          <tr>
            <td><strong>Ізоляція</strong></td>
            <td>Firecracker microVM</td>
            <td>Hyper-V sandbox</td>
            <td>gVisor</td>
            <td>V8 Isolates</td>
          </tr>
          <tr>
            <td><strong>IAM</strong></td>
            <td>IAM Roles, resource policies</td>
            <td>Managed Identity, RBAC</td>
            <td>Service Accounts, IAM</td>
            <td>API tokens, Workers KV</td>
          </tr>
          <tr>
            <td><strong>Secrets</strong></td>
            <td>Secrets Manager, SSM</td>
            <td>Key Vault</td>
            <td>Secret Manager</td>
            <td>Workers Secrets</td>
          </tr>
          <tr>
            <td><strong>Network</strong></td>
            <td>VPC, PrivateLink</td>
            <td>VNet integration</td>
            <td>VPC Connector</td>
            <td>N/A (edge)</td>
          </tr>
          <tr>
            <td><strong>Logging</strong></td>
            <td>CloudWatch, X-Ray</td>
            <td>Application Insights</td>
            <td>Cloud Logging, Trace</td>
            <td>Workers Analytics</td>
          </tr>
          <tr>
            <td><strong>Compliance</strong></td>
            <td>SOC, PCI, HIPAA, FedRAMP</td>
            <td>SOC, PCI, HIPAA, FedRAMP</td>
            <td>SOC, PCI, HIPAA</td>
            <td>SOC 2, PCI (обмежено)</td>
          </tr>
        </table>

        <h3>Приклад безпечної Lambda функції</h3>
        <pre>
// secure-lambda-example.js
const { SecretsManagerClient, GetSecretValueCommand } = require("@aws-sdk/client-secrets-manager");
const { DynamoDBClient, PutItemCommand } = require("@aws-sdk/client-dynamodb");

// Кешування секретів для warm containers
let cachedDbCredentials = null;

// Безпечна функція отримання секретів
async function getDbCredentials() {
  if (cachedDbCredentials) {
    return cachedDbCredentials;
  }

  const client = new SecretsManagerClient({});
  const command = new GetSecretValueCommand({
    SecretId: process.env.DB_SECRET_ARN // ARN, не значення!
  });

  const response = await client.send(command);
  cachedDbCredentials = JSON.parse(response.SecretString);
  return cachedDbCredentials;
}

// Валідація вхідних даних
function validateInput(event) {
  const body = JSON.parse(event.body || '{}');

  // Whitelist дозволених полів
  const allowedFields = ['userId', 'action', 'timestamp'];
  const sanitized = {};

  for (const field of allowedFields) {
    if (body[field]) {
      // Санітизація - тільки alphanumeric та дефіс
      if (typeof body[field] === 'string') {
        sanitized[field] = body[field].replace(/[^a-zA-Z0-9-]/g, '');
      }
    }
  }

  // Валідація обов'язкових полів
  if (!sanitized.userId || sanitized.userId.length > 36) {
    throw new Error('Invalid userId');
  }

  return sanitized;
}

exports.handler = async (event, context) => {
  const correlationId = event.headers?.['x-correlation-id'] || context.awsRequestId;

  // Structured logging без sensitive data
  console.log(JSON.stringify({
    level: 'INFO',
    correlationId,
    message: 'Processing request',
    httpMethod: event.httpMethod,
    path: event.path,
    // НЕ логуємо body, headers з токенами!
  }));

  try {
    // Валідація
    const input = validateInput(event);

    // Отримання credentials безпечно
    const creds = await getDbCredentials();

    // Бізнес-логіка...
    const dynamoDB = new DynamoDBClient({});
    await dynamoDB.send(new PutItemCommand({
      TableName: process.env.TABLE_NAME,
      Item: {
        pk: { S: input.userId },
        action: { S: input.action },
        timestamp: { N: String(Date.now()) }
      }
    }));

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'X-Correlation-Id': correlationId
      },
      body: JSON.stringify({ success: true })
    };

  } catch (error) {
    console.log(JSON.stringify({
      level: 'ERROR',
      correlationId,
      message: 'Request failed',
      errorType: error.name,
      // НЕ логуємо error.message - може містити sensitive data
    }));

    return {
      statusCode: error.name === 'ValidationError' ? 400 : 500,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        error: 'Request failed',
        correlationId // для troubleshooting
        // НЕ повертаємо stack trace!
      })
    };
  }
};
        </pre>
      </section>

      <section>
        <h2>Висновки</h2>
        <p>Serverless змінює парадигму розробки та безпеки. Хоча провайдер бере на себе більше відповідальності за інфраструктуру, нові виклики виникають на рівні коду, конфігурації та архітектури.</p>

        <h3>Ключові тези</h3>
        <ul>
          <li><strong>Serverless ≠ No Security:</strong> відповідальність зміщується, але не зникає</li>
          <li><strong>Least Privilege критичний:</strong> Capital One breach — яскравий приклад</li>
          <li><strong>Event-driven = нові вектори:</strong> Event Data Injection, Poisoned Functions</li>
          <li><strong>Ізоляція еволюціонує:</strong> Firecracker, gVisor забезпечують безпеку multi-tenancy</li>
          <li><strong>Observability складніша:</strong> distributed systems потребують distributed tracing</li>
        </ul>

        <h3>Тренди</h3>
        <ul>
          <li>Edge computing (Cloudflare Workers, Lambda@Edge)</li>
          <li>WebAssembly для portable serverless</li>
          <li>Serverless containers (Cloud Run, Fargate)</li>
          <li>AI/ML serverless (SageMaker Serverless)</li>
        </ul>
      </section>

      <section>
        <h2>Питання для самоперевірки</h2>
        <ol>
          <li>Чим відрізняється FaaS від BaaS?</li>
          <li>Що таке cold start і як його мінімізувати?</li>
          <li>Які специфічні загрози характерні для serverless (OWASP Serverless Top 10)?</li>
          <li>Як Firecracker забезпечує ізоляцію між функціями?</li>
          <li>У чому різниця між підходами Firecracker та gVisor?</li>
          <li>Чому не варто зберігати секрети в environment variables?</li>
          <li>Як Capital One breach пов'язаний з serverless?</li>
          <li>Які best practices IAM для Lambda функцій?</li>
        </ol>
      </section>

    </article>

    <footer id="footer"></footer>
  </main>

  <script src="../../js/main.js"></script>

</body>
</html>
